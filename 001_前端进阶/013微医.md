# 微医
	 
## 1、介绍JS数据类型，基本数据类型和引用数据类型的区别

基本类型： null、undefined、number、string、boolen、symbol
引用类型： object、array、function

基本类型： 值的保存
引用类型： 内存指针的保存


*
*
*
*
*
*
*
*
*
*
*
*
	 
## 2、Array是Object类型吗

是
*
*
*
*
*
*
*
*
*
*
*
*
	
## 3、数据类型分别存在哪里

1、基本类型存放于栈内存 Undefined、Null、Boolean、Number和String

基本数据类型存放存放于栈内存。栈，只允许在一端进行插入或者删除操作的线性表，是一种先进后出的数据结构，动态分配的空间由程序猿分配释放，若程序员不释放，程序结束时可能由操作系统回收，分配方式倒是类似于链表。（题外话：队列：先进先出FIFO）


2、引用类型 Object类型，包括Object、Array、Function、return的Data等

引用类型的存储需要内存的栈和堆共同完成，栈内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址


*
*
*
*
*
*
*
*
*
*
*
*


	 
## 4、var a  = {name: "前端开发"}; var b = a; a = null那么b输出什么

 {name: "前端开发"}

*
*
*
*
*
*
*
*
*
*
*
*
	 
## 5、var a = {b: 1}存放在哪里

 a指针放在栈中

 {b:1}放在堆中

 a指针指向{b:1}

*
*
*
*
*
*
*
*
*
*
*
*
	 
## 6、var a = {b: {c: 1}}存放在哪里

*
*
*
*
*
*
*
*
*
*
*
*
	 
## 7、栈和堆的区别

首先JavaScript中的变量分为基本类型和引用类型。基本类型就是保存在栈内存中的简单数据段，而引用类型指的是那些保存在堆内存中的对象。

1、基本类型

         基本类型有Undefined、Null、Boolean、Number 和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。   

2、引用类型

       引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。如下图所示：栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。由于这种值的大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。 这样，当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问当我们看到一个变量类型是已知的，就分配在栈里面，比如INT,Double等。其他未知的类型，比如自定义的类型，因为系统不知道需要多大，所以程序自己申请，这样就分配在堆里面。基本类型大小固定，引用类型大小不固定，分开存放使得程序运行占用内存最小。

3、栈内存：存放基本类型。 堆内存：存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象。）

4、基本类型在当前执行环境结束时销毁，而引用类型不会随执行环境结束而销毁，只有当所有引用它的变量不存在时这个对象才被垃圾回收机制回收。

*
*
*
*
*
*
*
*
*
*
*
*

	 
## 8、垃圾回收时栈和堆的区别

 *
*
*
*
*
*
*
*
*
*
*
*
## 9、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少
	 
## 10、栈和堆具体怎么存储
	 
## 11、介绍闭包以及闭包为什么没清除
	 
## 12、闭包的使用场景
	 
## 13、JS怎么实现异步

1、回调函数

2、时间监听

3、发布、订阅

4、promise

5、generator

6、async、await

	 
## 14、异步整个执行周期
	 
## 15、Promise的三种状态
	 
## 16、Async/Await怎么实现
	 
## 17、Promise和setTimeout执行先后的区别
	 
## 18、JS为什么要区分微任务和宏任务
	 
## 19、Promise构造函数是同步还是异步执行，then呢
	 
## 20、发布-订阅和观察者模式的区别
	 
## 21、JS执行过程中分为哪些阶段
	 
## 22、词法作用域和this的区别
	 
## 23、平常是怎么做继承
	 
## 24、深拷贝和浅拷贝
	 
## 25、loadsh深拷贝实现原理
	 
## 26、ES6中let块作用域是怎么实现的
	 
## 27、React中setState后发生了什么
	 
## 28、setState为什么默认是异步
	 
## 29、setState什么时候是同步的
	 
## 30、为什么3大框架出现以后就出现很多native（RN）框架（虚拟DOM）
	 
## 31、虚拟DOM主要做了什么
	 
## 32、虚拟DOM本身是什么（JS对象）
	 
## 33、304是什么
	 
## 34、打包时Hash码是怎么生成的
	 
## 35、随机值存在一样的情况，如何避免
	 
## 36、使用webpack构建时有无做一些自定义操作
	 
## 37、webpack做了什么
	 
## 38、a，b两个按钮，点击aba，返回顺序可能是baa，如何保证是aba（Promise.then）
	 
## 39、node接口转发有无做什么优化
	 
## 40、node起服务如何保证稳定性，平缓降级，重启等
	 
## 41、RN有没有做热加载
	 
## 42、RN遇到的兼容性问题
	 
## 43、RN如何实现一个原生的组件
	 
## 44、RN混原生和原生混RN有什么不同
	 
## 45、什么是单页项目
	 
## 46、遇到的复杂业务场景
	 
## 47、Promise.all实现原理

