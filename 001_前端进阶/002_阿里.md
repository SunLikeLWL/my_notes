# 阿里
	 
## 1、使用过的koa2中间件
	 
## 2、koa-body原理
	 
## 3、介绍自己写过的中间件
	 
## 4、有没有涉及到Cluster
	 
## 5、介绍pm2

pm2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡、而且使用非常简单。

安装

npm install -g pm2

### 入门教程
一般我们通过npm start 启动应用，其实是调用node ./bin/wwww。 那么，换成pm2就是
pm2 start ./bin/www --watch

### 常用命令

--watch: 监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不监听的目录，最好通过配置文件

-i  --instance: 启动多少个实例，可以用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目

-n -- name应用名称。查看应用信息的时候可以用到

-o --output <path>: 标准输出日志文件的路径

-e --error <path> : 错误输出日志文件


--interpreter <interpreter>


####  1、启动：

pm2 start app.js --watch - i 2

#### 2、重启：

pm2 restart app.js

#### 3、停止

pm2 stop app_name| app_id

#### 4、停止全部

pm2 stop all

#### 5、删除

pm2 delete app_name || app_id


#### 6、删除全部

pm2 delete all


#### 7、查看进程状态

pm2 list


### 配置文件









	 
## 6、master挂了的话pm2怎么处理
	 
## 7、如何和MySQL进行通信
	 
## 8、React生命周期及自己的理解

## 周期
1、装在过程（Mount）：组件第一个在DOM树种渲染的过程；
2、跟新过程（Update）：组件重新渲染的过程
3、卸载过程（Unmount）：组件从DOM中删除的过程

### 装载过程
组件第一次被渲染的时候，一次调用的函数为：
constructor()

getInitialState();

getDefaultProps();

componentWillMount();

render();

componentDidMnount();


1、constructor

ES6中每个类的构造函数，要创建一个组件的实例就要调用相应的构造函数。单并不是每个组件都要定自己的构造函数，比如无状态的React组件。一个组件调用构造函数， 往往是为了两个目的：
初始化state
绑定成员函数的this环境

getInitState和getDefaultProps

getInitState: 该函数返回值用来初始化state 
getDefaultProps: 该函数返回值用来初始化props

这两者只有用React.createClass方法创造出来的组件类才会发生作用，并且React.createClass已经被Fb官方废弃


2.componentWilMount

这个函数没有存在感，因为这个时候没有任何渲染出来的结果，调用setState修改状态也不会触发重新渲染，并且在这里做的事情完全可以提前到constructor


3、render

可以说React组件中最重要的函数，因为React组件的父类React.component类对除render之外的生命周期函数都有默认实现

render并不做渲染工作，只是返回一个JSX描述的结构，最终由React库根据返回对象决定如何渲染


render应该是一个纯函数，完全根据state和props来决定返回结果，而不产生副作用，所以render中调用setState是错的


4、componentDidMount
  componentDiMount并不是在render调用后立即调用，其调用的时候render返回的JSX已经渲染了

  componentWillMount可以在服务器端和浏览器端调用，但是componentDidMount只能在浏览器端调用（因为‘装载’操作过程是不可能在服务端完成的）

  异步请求数据一般都在该函数内进行



### 更新过程

componentWillReceiveProps()

shouldComponentUpdate()

render()

componentDidUpdate()


更新过程并不是总是执行所有函数


1、componentWillReceiveProps

只要是父组件的render函数被调用，在render里面渲染的子组件就会经历更新过程，不管父组件传递给子组件的props有没有改变，都会触发componentWillReseiveProps

  注意通过setState触发的更新过程不会调用这个函数，不然就死循环了


  2、shouldComponentUpdate
    应该是render函数之外最重要的函数了。他决定了一个组件什么时候需不需要渲染。render和shouldComponentUpdate是React中唯二需要有返回值的函数，shouldComponentUpdate返回一个布尔值，告诉React是否需要继续持续更新，若为true则继续，为false则停止更新，不会触发之后的重新渲染


  3、componentWillUpdate
  即将render时执行，初始化render时不执行。在这里同样不能setState，这个函数调用之后，就会把nextProps和nextState分别设置到props和state中，紧接着调用render


  4、render


  可以说React组件中最重要的函数，因为React组件的父类React.component类对除render之外的生命周期函数都有默认实现

render并不做渲染工作，只是返回一个JSX描述的结构，最终由React库根据返回对象决定如何渲染


render应该是一个纯函数，完全根据state和props来决定返回结果，而不产生副作用，所以render中调用setState是错的


5、componentDidUpdate
组件跟新完成之后执行，初始化render执行

### 卸载过程

卸载过程只有一个函数componentWillUnmount，当render组件要从DOM树上删除前，该函数就会被调用，多以这个函数适合做一些清理工作

eg: 在componnetWillUnmount中用非react方法创建的DOM元素，如果不处理可能会发生内存泄露，因此可以在改函数中将其清理干净









	 
## 9、如何配置React-Router


	 
## 10、路由的动态加载模块
	 
## 11、服务端渲染SSR
	 
## 12、介绍路由的history
	 
## 13、介绍Redux数据流的流程
	 
## 14、Redux如何实现多个组件之间的通信，多个组件使用相同状态如何进行管理
	 
## 15、多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块
	 
## 16、使用过的Redux中间件
	 
## 17、如何解决跨域的问题
   
## 18、常见Http请求头
	 
## 19、移动端适配1px的问题

因为css中的1px并不等于移动设备1px，这些由于不同手机有不同的像素密度。在window对象中有一个devicePixelRadio属性，他可以反应css中的像素与设备的像素比

devicePixelRatio的官方定义为：设备物理像素和设备独立像素的比例，
devicePixelRadio = 物理像素/独立像素

### 方法
1、0.5px边框


css:
@media (-webkit-min-device-pixel-radio:2){
   div{
       border-width: 0.5px;
   }
}

js:

if(window.devicePixelRadio && devicePixelRadio>=2){
   var testElem = document.createElement("div);
   testElemt.style.border =  '.5px solid transparent';
   documnet.border.appendChild(testEelem);
}

if(testElem.offsetHeight == 1){
     document.querySelecter("html).classlist.add("hairline);
}

document.body.removeChild(testElement);



2、使用border-image



3、使用background-image



4、多背景渐变试下


 background:
    linear-gradient(#000, #000 100%, transparent 100%) left / 1px 100% no-repeat,
    linear-gradient(#000, #000 100%, transparent 100%) right / 1px 100% no-repeat,
    linear-gradient(#000,#000 100%, transparent 100%) top / 100% 1px no-repeat,
    linear-gradient(#000,#000 100%, transparent 100%) bottom / 100% 1px no-repeat
}



5、使用bo-shadow模拟边框




6、viewport+rem实现



7、伪类+transform实现


.scale-1px{
  position: relative;
  border:none;
}
.scale-1px:after{
  content: '';
  position: absolute;
  bottom: 0;
  background: #000;
  width: 100%;
  height: 1px;
  -webkit-transform: scaleY(0.5);
  transform: scaleY(0.5);
  -webkit-transform-origin: 0 0;
  transform-origin: 0 0;
}
	 
## 10、介绍flex布局
	 
## 21、其他css方式设置垂直居中
	 
## 22、居中为什么要使用transform（为什么不使用marginLeft/Top）
	 
## 23、使用过webpack里面哪些plugin和loader
	 
## 24、webpack里面的插件是怎么实现的
	 
## 25、dev-server是怎么跑起来
	 
## 26、项目优化
	 
## 27、抽取公共文件是怎么配置的
	 
## 28、项目中如何处理安全问题
	 
## 29、怎么实现this对象的深拷贝

