## 1、hooks

### 为什么引入hooks
   react官方给出了的动机是用来解决长时间使用和维护react过程中遇到的一些难以避免的问题。
   
   1、难以重用和共享组件中的与状态相关的逻辑；

   2、逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的local state 时，每个生命周期函数中可能会包含各种互不相关的逻辑在里面

   3、类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题


   4、由于业务变动，函数组件不得不改为类组件等等
*
*
*
*
*
*
*
*
*
*
*
*
*
*





## 2、thunk

thunk是函数(function)的另一种表达方式。但它并不仅仅是传统的函数，而是由其他函数返回来的一种特殊且不常见的函数的别称

redux-thunk

redux 中间件

*
*
*
*
*
*
*
*
*
*
*
*
*
*





## 3、中间件

 ### 概念：
  中间件（英语：Middleware），是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通，特别是应用软件对于系统软件的集中的逻辑，在现代信息技术应用框架如Web服务、面向服务的体系结构等中应用比较广泛。
  


*
*
*
*
*
*
*
*
*
*
*
*
*
*


## 4、Web Worker

### 用途
web Worker的意义在于可以将一些耗时的数据处理操作从主线程中剥离，使主线程更加专注于页面渲染和交互

1、懒加载

2、文本分析

3、流媒体数据处理

4、canvas图形绘制

5、图像处理

### 限制

1、同源限制

2、无法访问DOM节点

3、运行在另一个上下文，无法使用Window对象

4、Web Worker 的运行不影响主线程，但与主线程交互时受到主线程单线程的瓶颈制约。换而言之，如果Web Worker线程频繁与主线程进行交互，主线程由于需要处理交互，仍有可能使得页面发生阻塞


5、共享线程可以被多个浏览上下文调用，但所有这些浏览上下文必须同源


### 线程创建

专用线程由Worker()方法创建，可以接收两个参数，第一参数是必填的脚本的位置，第二个是可选的配置对象，可以指定type、credentials、name三个属性


var worker = new Worker("worker.js);

 共享线程使用Shared Worker() 方法创建，同样支持两个参数，第一参数是必填的脚本的位置，第二个是可选的配置对象，可以指定type、credentials、name三个属性

 var shareWorker = new Worker("shared-worker.js")


### 数据传递

Worker线程和主线程通过postMessage()方法发送消息，通过onmessage事件接收消息。在这个过程中数据并不是被共享的，而是被复制的。值得注意的是Error和Function对象不能被结构化克隆算法复制

postMessage() 一次只能发送一个对象，如果要发送多个参数可以将参数包装为数组或者对象进行传递


实例：

// 主线程

 var worker = new Worker("worker.js");
 worker.postMessage([10,24])

 worker.onmessage = function(e){
     console.log(e.data);
 }

 // Worker 线程

 onmessage = function(e){
    if(e.data.length>1){
         postMessage(e.data[1] - e.data[0])
    }
 }


### 关闭Worker 
   可以在主线程使用terminate()方法或在Worker线程中使用close()方法关闭worker。
  
  // 主线程
   worker.terminate();

 // worker线程
 self.close()


 // shared worker线程中

 self.port.close();



### 错误处理

 可以通过主线程或者worker线程中设置onerror和onmessageerror的回调函数对错误进行处理。onerror在Worker的error事件触发并冒泡执行，onmessageerror在worker收到的消息不能进行反序列化时触发的

### 加载外部脚本

Web Worker 通过importScripts()方法，能够将外部脚本文件加载到Worker中。


### 子线程

### 嵌入式Worker

### 关于postMessage

Web Worker 中，Worker 线程和主线程之间使用结构化克隆算法（The structured clone algorithm）进行数据通信。结构化克隆算法是一种通过递归输入对象构建克隆的算法，算法通过保存之前访问过的引用的映射，避免无限遍历循环。这一过程可以理解为，在发送方使用类似 JSON.stringfy() 的方法将参数序列化，在接收方采用类似 JSON.parse() 的方法反序列化。
但是，一次数据传输就需要同时经过序列化和反序列化，如果数据量大的话，这个过程本身也可能造成性能问题。因此， Worker 中提出了 Transferable Objects 的概念，当数据量较大时，我们可以选择在将主线程中的数据直接移交给 Worker 线程。值得注意的是，这种转移是彻底的，一旦数据成功转移，主线程将不能访问该数据。这个移交的过程仍然通过 postMessage 进行传递。
 

 ### 上下文

 ### Worker 中可以使用的函数和类

 时间相关

clearInterval()
clearTimeout()
setInterval()
setTimeout

Worker 相关

importScripts()
close()
postMessage()

 

 


## 5、polyfill
https://juejin.im/post/5d18b4b56fb9a07ec56e8e00

### 概念
polyfill 在英文里有垫片的意思，意为兜底的东西。在计算机科学中，指的是未能实现的顾客端上进行的“兜底”操作，打补丁在前端er是件习以为常的事情，结合笔者日常工作经验

### 方法

1、手动打补丁

2、根据覆盖率自动打补丁

3、根据浏览器特性，动态打补丁





 



## 6、React 高阶组件
https://juejin.im/post/59b36b416fb9a00a636a207e


### 概念
一个传入一个组件，返回另一个组件的函数，其概念与高阶的函数作为参数传入类似

const EnhancedComponent = higherOrderComponent(WrappedComponent);


以上通过higherOrderComponent 函数返回的EnhancedComponent就是一个高阶组件。所以简单来说，高阶只是一种设计模式，并非一种的组件类型


### 为何使用

1、代码复用：这就是高阶组件最基本的功能。组件是React最小的单元，两个相似度很高的组件通过将组件重复部分抽取出来，再通过高阶组件扩展，增删改props，可以达到组件可复用的目的；

2、条件渲染：控制组件的渲染逻辑，常见case： 鉴权

3、生命周期捕获/劫持：借助父组件子组件生命周期规则捕获子组件的生命周期，常见case： 打点




## 7、7中解决移动端Retina屏幕1px边框的问题

### 造成边框变粗的原因
因为css中的1px并不等于移动设备1px，这些由于不同手机有不同的像素密度。在window对象中有一个devicePixelRadio属性，他可以反应css中的像素与设备的像素比

devicePixelRatio的官方定义为：设备物理像素和设备独立像素的比例，
devicePixelRadio = 物理像素/独立像素

### 方法
1、0.5px边框


css:
@media (-webkit-min-device-pixel-radio:2){
   div{
       border-width: 0.5px;
   }
}

js:

if(window.devicePixelRadio && devicePixelRadio>=2){
   var testElem = document.createElement("div);
   testElemt.style.border =  '.5px solid transparent';
   documnet.border.appendChild(testEelem);
}

if(testElem.offsetHeight == 1){
     document.querySelecter("html).classlist.add("hairline);
}

document.body.removeChild(testElement);



2、使用border-image



3、使用background-image



4、多背景渐变试下


 background:
    linear-gradient(#000, #000 100%, transparent 100%) left / 1px 100% no-repeat,
    linear-gradient(#000, #000 100%, transparent 100%) right / 1px 100% no-repeat,
    linear-gradient(#000,#000 100%, transparent 100%) top / 100% 1px no-repeat,
    linear-gradient(#000,#000 100%, transparent 100%) bottom / 100% 1px no-repeat
}



5、使用bo-shadow模拟边框




6、viewport+rem实现



7、伪类+transform实现


.scale-1px{
  position: relative;
  border:none;
}
.scale-1px:after{
  content: '';
  position: absolute;
  bottom: 0;
  background: #000;
  width: 100%;
  height: 1px;
  -webkit-transform: scaleY(0.5);
  transform: scaleY(0.5);
  -webkit-transform-origin: 0 0;
  transform-origin: 0 0;
}