## 1、hooks

### 为什么引入hooks
   react官方给出了的动机是用来解决长时间使用和维护react过程中遇到的一些难以避免的问题。
   
   1、难以重用和共享组件中的与状态相关的逻辑；

   2、逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的local state 时，每个生命周期函数中可能会包含各种互不相关的逻辑在里面

   3、类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题


   4、由于业务变动，函数组件不得不改为类组件等等
*
*
*
*
*
*
*
*
*
*
*
*
*
*





## 2、thunk

thunk是函数(function)的另一种表达方式。但它并不仅仅是传统的函数，而是由其他函数返回来的一种特殊且不常见的函数的别称

redux-thunk

redux 中间件

*
*
*
*
*
*
*
*
*
*
*
*
*
*





## 3、中间件

 ### 概念：
  中间件（英语：Middleware），是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通，特别是应用软件对于系统软件的集中的逻辑，在现代信息技术应用框架如Web服务、面向服务的体系结构等中应用比较广泛。
  


*
*
*
*
*
*
*
*
*
*
*
*
*
*


## 4、Web Worker

### 用途
web Worker的意义在于可以将一些耗时的数据处理操作从主线程中剥离，使主线程更加专注于页面渲染和交互


1、懒加载

2、文本分析

3、流媒体数据处理

4、canvas图形绘制

5、图像处理

### 限制

1、同源限制

2、无法访问DOM节点

3、运行在另一个上下文，无法使用Window对象

4、Web Worker 的运行不影响主线程，但与主线程交互时受到主线程单线程的瓶颈制约。换而言之，如果Web Worker线程频繁与主线程进行交互，主线程由于需要处理交互，仍有可能使得页面发生阻塞


5、共享线程可以被多个浏览上下文调用，但所有这些浏览上下文必须同源


### 线程创建

专用线程由Worker()方法创建，可以接收两个参数，第一参数是必填的脚本的位置，第二个是可选的配置对象，可以指定type、credentials、name三个属性


var worker = new Worker("worker.js);

 共享线程使用Shared Worker() 方法创建，同样支持两个参数，第一参数是必填的脚本的位置，第二个是可选的配置对象，可以指定type、credentials、name三个属性

 var shareWorker = new Worker("shared-worker.js")


### 数据传递

Worker线程和主线程通过postMessage()方法发送消息，通过onmessage事件接收消息。在这个过程中数据并不是被共享的，而是被复制的。值得注意的是Error和Function对象不能被结构化克隆算法复制

postMessage() 一次只能发送一个对象，如果要发送多个参数可以将参数包装为数组或者对象进行传递


实例：

// 主线程

 var worker = new Worker("worker.js");
 worker.postMessage([10,24])

 worker.onmessage = function(e){
     console.log(e.data);
 }

 // Worker 线程

 onmessage = function(e){
    if(e.data.length>1){
         postMessage(e.data[1] - e.data[0])
    }
 }


### 关闭Worker 
   可以在主线程使用terminate()方法或在Worker线程中使用close()方法关闭worker。
  
  // 主线程
   worker.terminate();

 // worker线程
 self.close()


 // shared worker线程中

 self.port.close();



### 错误处理

 可以通过主线程或者worker线程中设置onerror和onmessageerror的回调函数对错误进行处理。onerror在Worker的error事件触发并冒泡执行，onmessageerror在worker收到的消息不能进行反序列化时触发的

### 加载外部脚本

Web Worker 通过importScripts()方法，能够将外部脚本文件加载到Worker中。


### 子线程

### 嵌入式Worker

### 关于postMessage

Web Worker 中，Worker 线程和主线程之间使用结构化克隆算法（The structured clone algorithm）进行数据通信。结构化克隆算法是一种通过递归输入对象构建克隆的算法，算法通过保存之前访问过的引用的映射，避免无限遍历循环。这一过程可以理解为，在发送方使用类似 JSON.stringfy() 的方法将参数序列化，在接收方采用类似 JSON.parse() 的方法反序列化。
但是，一次数据传输就需要同时经过序列化和反序列化，如果数据量大的话，这个过程本身也可能造成性能问题。因此， Worker 中提出了 Transferable Objects 的概念，当数据量较大时，我们可以选择在将主线程中的数据直接移交给 Worker 线程。值得注意的是，这种转移是彻底的，一旦数据成功转移，主线程将不能访问该数据。这个移交的过程仍然通过 postMessage 进行传递。
 

 ### 上下文

 ### Worker 中可以使用的函数和类

 时间相关

clearInterval()
clearTimeout()
setInterval()
setTimeout

Worker 相关

importScripts()
close()
postMessage()

 

 


## 5、polyfill
https://juejin.im/post/5d18b4b56fb9a07ec56e8e00

### 概念
polyfill 在英文里有垫片的意思，意为兜底的东西。在计算机科学中，指的是未能实现的顾客端上进行的“兜底”操作，打补丁在前端er是件习以为常的事情，结合笔者日常工作经验

### 方法

1、手动打补丁

2、根据覆盖率自动打补丁

3、根据浏览器特性，动态打补丁





 



## 6、React 高阶组件
https://juejin.im/post/59b36b416fb9a00a636a207e


### 概念
一个传入一个组件，返回另一个组件的函数，其概念与高阶的函数作为参数传入类似

const EnhancedComponent = higherOrderComponent(WrappedComponent);


以上通过higherOrderComponent 函数返回的EnhancedComponent就是一个高阶组件。所以简单来说，高阶只是一种设计模式，并非一种的组件类型


### 为何使用

1、代码复用：这就是高阶组件最基本的功能。组件是React最小的单元，两个相似度很高的组件通过将组件重复部分抽取出来，再通过高阶组件扩展，增删改props，可以达到组件可复用的目的；

2、条件渲染：控制组件的渲染逻辑，常见case： 鉴权

3、生命周期捕获/劫持：借助父组件子组件生命周期规则捕获子组件的生命周期，常见case： 打点




## 7、解决移动端Retina屏幕1px边框的问题

### 造成边框变粗的原因
因为css中的1px并不等于移动设备1px，这些由于不同手机有不同的像素密度。在window对象中有一个devicePixelRadio属性，他可以反应css中的像素与设备的像素比

devicePixelRatio的官方定义为：设备物理像素和设备独立像素的比例，
devicePixelRadio = 物理像素/独立像素

### 方法
1、0.5px边框


css:
@media (-webkit-min-device-pixel-radio:2){
   div{
       border-width: 0.5px;
   }
}

js:

if(window.devicePixelRadio && devicePixelRadio>=2){
   var testElem = document.createElement("div);
   testElemt.style.border =  '.5px solid transparent';
   documnet.border.appendChild(testEelem);
}

if(testElem.offsetHeight == 1){
     document.querySelecter("html).classlist.add("hairline);
}

document.body.removeChild(testElement);



2、使用border-image



3、使用background-image



4、多背景渐变试下


 background:
    linear-gradient(#000, #000 100%, transparent 100%) left / 1px 100% no-repeat,
    linear-gradient(#000, #000 100%, transparent 100%) right / 1px 100% no-repeat,
    linear-gradient(#000,#000 100%, transparent 100%) top / 100% 1px no-repeat,
    linear-gradient(#000,#000 100%, transparent 100%) bottom / 100% 1px no-repeat
}



5、使用bo-shadow模拟边框




6、viewport+rem实现



7、伪类+transform实现


.scale-1px{
  position: relative;
  border:none;
}
.scale-1px:after{
  content: '';
  position: absolute;
  bottom: 0;
  background: #000;
  width: 100%;
  height: 1px;
  -webkit-transform: scaleY(0.5);
  transform: scaleY(0.5);
  -webkit-transform-origin: 0 0;
  transform-origin: 0 0;
}





## 8 mapState

当组件需要获取多个状态的时候，将这些状态都声明为计算机属性会有些复杂和冗余。为了解决这个问题，我们可以使用mapState辅助函数帮助我们生成计算属性，

// 在单独构建的版本中辅助函数为Vuex.mapState
import {mapState} from 'vuex';

export default{
   computed: mapState({
       // 箭头函数可以使代码更加简练
       count: state = >state.count,
       // 传字符串参数 'count' 等同于'state =>state.count'
       countAlias:'count',
       countPlusLocationState(state){
          return state.count + this.localCount
       }
   })
}

mapState 函数返回的是一个对象。通常，我们需要使用一个工具函数将多个对象合并成一个，以使我们可以将最终对象传给computed属性。但是自从有了对象展开运算符，我们可以极大地简化写法：

computed:{
   localComputed(){

   }
   ...mapState({

   })
}




## 9、hook 




react 为什么要搞一个 hook

react的核心思想就是，将一个页面拆成一堆独立的，可复用的组件，而且自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用react，你会发现的你的项目实际上很多组件冗长且难以复用。尤其是那些写成 class的组件，他们本身包含了状态，所以复用这类组件就变得麻烦




## 10、React无状态组件

     https://blog.csdn.net/r122555/article/details/82783944

  ### 无状态组件优势
     
     无状态组件可以通过减少继承Component而来的生命周期函数而达到性能优化的效果。从本质上来说，无状态组件就是一个单纯的render函数，所以无状态组件的缺点是显而易见的。因为他没有shouldComponentUpdate生命周期函数，所以没次state更新，他都会重新绘制render函数


     原则上，只要一个组件只具有render函数时，都可以封装成无状态组件，但是我认为其较佳的使用场景应该是listView组件的renderRow函数内部，因为没次对listView组件的数据进行操作都会不可避免调用renderRow函数，而这时无状态组件无生命周期的特性恰好有效的显示出来。虽然此时是否将renderRow里面的组件拆分出来在效果上都是一样的，但是组件的拆分有利于降低耦合，也有利于隔离这些单元进行独立测试


### PureComponent

纯组件是通过控制shouldComponentUpdate生命周期函数，减少render调用次数来减少性能的损耗的。这相对于Component来说，减少了手段判断state变化的繁琐操作，但该组件有个定的缺陷，以为他只能进行一层浅比较，简单的说他只比较props和state的内存地址，如果内存地址相同，则shouldComponentUpate生命周期就返回false






## 11、wepy

### 介绍

是小程序最早的框架之一，是一款让小程序支持组件化开的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化。Promise，Async，Function的引入都是为了能让小程序项目变得更加简单，高效


### 特性

1、使用Vue Oberver 实现数据绑定

2、支持Vue watch/computed/mixin等特性

3、基于原生组件的实现组件化开发

4、支持Typescript




## 12、依赖注入

wiki上的解释是：依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该对象非（或者客户端）的一部分。

该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循以了依反转和单一职责原则。与服务定位器模式形成直接对比的是，他允许客户端了解客户端如何使用该系统找到依赖



AngularJS提供很好的依赖注入机制：

1、value

一个简单的javascript对象，用于向控制器传递值（配置阶段）
myApp.value('defalutInput',4);


2、factory
 一个函数用于返回值。在service的controller需要时创建
 通常我们使用factory函数来计算或返回值

 mainApp.factory('MathService',function(){
    var factory = {};
    factory.multiply = function(a,b){
       return a*b;
    }
   return factory;
 })

3、service

4、provider

   AngularJS中通过provider创建一个service、factory等（配置阶段）
   Provider中提供了一个factory方法get(),它用于返回value/service/factory

    mainApp.config(function($provide){
       $provide.provider('MathSertvice',function(){
          this.$get  =function(){
             var factory = {};
             factory.multiply = function(a,b){
                return a*b;
             }
             return factory;
          }
       })
    })


5、constant
   constant(常量)用来在配置阶段传递数组，。注意这个常量在配置阶段是不可用的。

   mainApp.constant("configParam","constant value");







## 13、angularJS

ng-app 指令定义得个angularJS应用程序

ng-model 指令把元素值（比如输入域的值）

ng-bind 指令把应用程序数据绑定到HTML视图



 