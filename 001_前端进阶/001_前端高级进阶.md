# 前端高级进阶

##  1、调用堆栈  *******************************************************

执行上下文就是当前javascript代码被解析和执行是所在环境的抽象概念，javascript中运行任何代码都是在执行上下文中运行的。
a、全局上下文
b、函数执行上下文
c、Eval函数执行上下文

执行栈，也叫调用栈，具有LIFO(Last In First Out)结构，用于存储在代码执行期间创建的所有执行上下文；

当javascript引擎首次读取脚本时，会创建一个全局执行上下文并将其Push到当前执行栈中。每当发生函数调用
时，引擎就会为该函数创建一个新的执行上下文并push到当前执行栈的栈顶；

引擎会运行执行上下文在执行栈栈顶的函数，根据LIFO规则，当前函数运行完成后，其对应的执行上下文将会从执行栈中
pop出，上下文控制权转到当前执行栈的下一个执行上下文；






## 2、作用域闭包  

### 概念
 函数与对其状态即词法环境的应用共同构成闭包(closure)。也就是说，闭包可以让你从内部函数访问外部函数作用域
。在javascript，函数在每次创建是生成闭包





## 3、this 全面解析 *******************************************************

### 前言
this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

### 总结
函数被调用时发生this绑定，this指向什么完全取决于函数在哪里被调用。

### this的绑定规则

1、默认绑定
 
 独立函数调用：独立函数调用时的this使用默认绑定规则，默认绑定规则下的this指向window(全局对象)
 严格模式：this无法使用默认绑定，this会绑定undefined


2、隐式绑定

当函数引用有上下文对象的时，隐式绑定规则会把函数中的this绑定到这个上下文对象

 var obj = {
     name:"xixi",
     foo:function(){
         console.log(this.name)
     }
 }

obj.foo();

对象属性引用链中只有上一层或者说最后一层在再调用中起作用

obj.obj1.foo();

 var obj = {
     name:"xixi",
     obj1:{
         name:"wenwen",
         foo:function(){
            console.log(this.name)
        }
     }
 }

隐式丢失： 被隐式绑定的函数会丢失绑定对象，而应用默认绑定，把this绑定到全局对象或者undefined(严格模式)上。


 
var a = "global";
var obj = {
    a:"obj",
    foo:function(){
        console.log(this.a);//global
    }
}
var bar = obj.foo;//函数别名
bar(); 


 
 var a = "global";
 var obj = {
     a: "obj",
     foo:function(){
         console.log(this.a);//global
     }
 }
var bar = obj.foo;//函数别名
function doFoo(fn){
    fn();
}
doFoo(bar); //global

setTimeout(obj.foo,3000)

3、显示绑定

通过call()和apply()方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this上，称之为显示绑定

4、new绑定
使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
 创建（或者说构造）一个新的对象
 这个新的对象被执行[[原型]]链接
 这个新对象会绑定到函数调用的this
 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象


 5、箭头函数绑定
    箭头函数绑定无法修改，new也不行


优先级：
箭头函数>new > call/apply > 隐式 > 默认


### new源码实现
    function create(){
        // 创建一个空的对象
        var obj = new Object();
        //获得构造函数，arguments中去掉第一个参数
        Con = [].shift.call(arguments);
        //  链接到原型，obj可以访问到构造函数原型中的属性
        obj.__proto__ = Con.prototype;
        // 绑定this实现继承，obj可以访问到构造函数的属性
        var ret =  Con.apply(obj,arguments);
        // 优先返回构造函数返回的对象；
        return ret instanceof Object ? ret: obj;
    }




## 4、深浅拷贝原理 *******************************************************
### 浅拷贝
只拷贝对象的基本类型值，并不复杂引用类型的值而是引用他的指针，
var a = {
    name: 12
}
var b = a;
b只是引用a的指针


### 深拷贝
深拷贝可以拥有一个对象所有属性和方法，实现真正的"独立自主"，不引用原来对
象的指针，开辟新的内存空间，和原来的对象不会相互影响


### 浅拷贝实现方法

  1、Object.assign();

   拷贝的只是属性值,只实现第一层的深拷贝，而不能进行深层的深拷贝，所以这个方法属于浅拷贝

  2、Object.create();
   这个方法创建了一个新的对象，使用现有的对象来提供新创建的对象的__proto__，实际上是地址引用，


   3、扩展运算符等
   let a = [1,2,3];
   let b = [...a];
   
   只是基于基本类型值的引用，并没有开辟新的空间

   


  ### 深拷贝实现方法

 1、JSON.parse(JSON.stringify(obj));

 

 2、利用递归的方法和for in遍历属性进行深拷贝

 function deepCopy(initialObj,copyObj){
     var obj =  copy||{};
     for(let i in initialObj){
         var prop = initialObj[i];
         if(typeof prop ==="obj"){
             obj[i] = prop.constructor===Array?[]:{},
             deepCopy(prop,obj[i]);
         }
         else{
             obj[i] = prop;
         }
     }
     return obj;
 }




## 5、原型 Prototype  

### 基本概念
每个函数都有一个prototype属性。
此属性是一个指针，能够指向一个对象，而且对象将会被构造函数创建的对象实例所共享，也就是会继承此对象
### 总结:
prototype所指向的对象是被构造函数所创建的对象实例所共用共享的。
创建的对象实例有一个内部属性[[Prototype]]，他是一个指针，指向函数原型(prototype)指向的对象。

### 构造函数 
constructor返回创建构造函数实例对象时构造函数的引用。
此属性值是对函数本身的引用，而不是一个包含函数名的字符串

 构造函数本身就是一个函数，与普通函数没有任何区别，不过为了规范一般将首字母大写

 ### Symbol
   是基本数据类型，但作为构造函数的来说并不完整，因为他不支持new Symbol

 
 ### construtor
   属性值是可以修改的，当时对于基本类型来说是只读的

### 原型链
   每一个对象都有一个原型对象，通过__proto__ 指针指向上一个原型，并从中继承属性和方法，同时原型对象也可能拥有原型，这样一层一层，最终指向null。这种关系被称为原型链，通过原型链一个对象会拥有定义在其他对象中的属性和方法









## 6、高阶函数  *******************************************************
   
   ### 高级函数
   参数或者是函数返回值是函数的函数。

   ### AOP面向切片编程
   1、当需要使用某个公共函数时需要这个函数执行前添加自己的逻辑，
   2、通常我们的做法不能是直接修改这个函数；
   3、而是通过AOP的方法利用高级函数和原型链的特点处理


   function say(name){
       console.log(name)
   }

   function before(){
       console.log("say前执行");
   }

   Function.prototype.beforeFn = function(){
       return (...argd)=>{
           before();
           this(...args);
       }
   }

   let beforeSay = say.beforeFn(before);

   beforeSay("xixi")


  ### 柯里化
   函数柯里化又叫分布求值，维基百科中对柯里化的定义：
   在数学和计算机科学中，合理化是一种讲使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受剩余的参数而且返回结果的新函数的技术。


   





## 7、事件机制 *******************************************************
   
   ### 事件
   文档或者浏览器窗口中发生的一些特定的交互瞬间，js和html的交互就是通过事件来实现的。
   可以使用监听器（或者处理程序）来预定事件，以便事件发生时执行相应的代码。

   ###  事件流
   描述的是从页面中就收事件的顺序。但是IE跟Netscape提出了差不多的完全相反的概念。IE
   的事件流式事件冒泡流，Netscape的事件流是事件捕获流。

   ### 事件冒泡
   IE的事件流叫事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点。

   ### 事件捕获
   Netscape提出了另一个事件流叫事件捕获。事件捕获的用意在于在事件达到预定目标之前捕获他




## 8、Event Loop 原理  
 
 ### 概念
 Event Loop 即事件循环，是指浏览器或Node的一种解决javascript单线程运行时不会阻塞的一种
 机制，也就时我们经常使用异步的理由。

### 堆
堆是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种是大堆，一种是小堆，
将根节点最大的堆叫最大堆或者大跟堆，根节点是最小的堆叫做最小堆或者小根堆。堆是线性数据结构，
相当于一维数组，有唯一后继。

### 栈
栈在计算机中是限定仅在表尾进行插入或者删除操作的线性表。栈是一种数据结构，他按照后进先出的
原则储存数据，先进的数据被压入栈底，最后的数据在栈顶，需要读取数据的时候从栈顶开始弹出数据。
栈是只能在某一端插入和删除的特殊线性表。

### 队列
只允许在表的前端(front)进行删除操作，而在后端的(rear)进行插入操作，和栈一样，队列是一种
受限的线性表


*
*
*
*
*
*
*
*
*
*


  



## 9、Promise 原理

### 1、基本结构
new Promise((resolve,reject)=>{
       setTimeout(()=>{
           resolve("FULFiLLED)
       })
})


构造函数promise必须接受一个函数作为参数，我们称该函数为handle，handle有包含resolve和reject两个参数，他们是两个函数。


定义一个判断一个变量是否为函数的方法，后面会用到

const isFunction = variable => typeof variable==== 'function';


首先，我么定义一个名为MyPromise的Class，他接受一个函数handle作为参数


class MyPromise{
    construtor(handle){
        if(!isFunction(handle){
            throw new Error("MyPromise must accept a function as parameter");
        })
    }
}


### 2、状态和值

Promise对象存在以下三种状态：


1、Pending 进行中

2、Fulfilled 已成功

3、Rejected 已失败

状态只会由Pending变成Fulfilled或者由Pending变成Rejected，而且状态改变之后不会再发生变化，会一直保持这个状态。


Promise的值是指状态改变时传递给回调函数的值


上文中handle函数包含resolve和reject两个参数，可以用于改变Promise的状态和传入Promise的值

new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve('FULFilled');
    },1000)
})



这里resolve传入的"FulFilled"就是Promise的值



resolve和reject


1、resolve：将Promise对象的状态从Pending变为Fulfilled

2、reject：将Promise对象的状态从Pending变为Reject

3、resolve和reject都可以传入任意类型的值作为参数，表示Promise对象成功Fulfilled和失败Rejected



### 3、Promise的then方法


 promise.then(onFulfilled,onRejected);

 

 ### 完整源码

// 判断变量否为function
const isFunction = variable => typeof variable === 'function'
// 定义Promise的三种状态常量
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
    constructor(handle) {
        if (!isFunction(handle)) {
            throw new Error('MyPromise must accept a function as a parameter')
        }
        // 添加状态
        this._status = PENDING
        // 添加状态
        this._value = undefined
        // 添加成功回调函数队列
        
            this._reject(err)
        }
    }
    // 添加resovle时执行的函数
    _resolve(val) { 
        const run = () => {
            if (this._status !== PENDING) re
            turn
            this._status  = FULFILLED
            // 依次执行成功队列中的函数，并清空队列
            const runFulfilled = (value) => {
                let cb;
                while (cb = this._fulfilledQueues.shift()) {
                    cb(value)
                }
       
            /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
            */
            if (val instanceof MyPromise) {
                val.then(value => {
                    this._value = value
                    runFulfilled(value)
                }, err => {
                    this._value = err
                    runRejected(err)
                })
            } else {
                this._value = val
                runFulfilled(val)
            }
        }
        // 为了支持同步的Promise，这里采用异步调用
        setTimeout(run, 0)
    }
    // 添加reject时执行的函数
    _reject(err) {
        if (this._status !== PENDING) return
        // 依次执行失败队列中的函数，并清空队列
        const run = () => {
            this._status = REJECTED
            this._value = err
            let cb;
            while (cb = this._rejectedQueues.shift()) {
                cb(err)
            }
        }
        // 为了支持同步的Promise，这里采用异步调用
        setTimeout(run, 0)
    }
    // 添加then方法
    then(onFulfilled, onRejected) {
        const { _value, _status } = this
        // 返回一个新的Promise对象
        return new MyPromise((onFulfilledNext, onRejectedNext) => {
            // 封装一个成功时执行的函数
            let fulfilled = value => {
                try {
                    if (!isFunction(onFulfilled)) {
                        onFulfilledNext(value)
                    } else {
                        let res = onFulfilled(value);
                        if (res instanceof MyPromise) {
                            // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                            res.then(onFulfilledNext, onRejectedNext)
                        } else {
                            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                            onFulfilledNext(res)
                        }
                    }
                } catch (err) {
                    // 如果函数执行出错，新的Promise对象的状态为失败
                    onRejectedNext(err)
                }
            }
            // 封装一个失败时执行的函数
            let rejected = error => {
                try {
                    if (!isFunction(onRejected)) {
                        onRejectedNext(error)
                    } else {
                        let res = onRejected(error);
                        if (res instanceof MyPromise) {
                            // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                            res.then(onFulfilledNext, onRejectedNext)
                        } else {
                            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                            onFulfilledNext(res)
                        }
                    }
                } catch (err) {
                    // 如果函数执行出错，新的Promise对象的状态为失败
                    onRejectedNext(err)
                }
            }
            switch (_status) {
                // 当状态为pending时，将then方法回调函数加入执行队列等待执行
                case PENDING:
                    this._fulfilledQueues.push(fulfilled)
                    this._rejectedQueues.push(rejected)
                    break
                // 当状态已经改变时，立即执行对应的回调函数
                case FULFILLED:
                    fulfilled(_value)
                    break
                case REJECTED:
                    rejected(_value)
                    break
            }
        })
    }
    // 添加catch方法
    catch(onRejected) {
        return this.then(undefined, onRejected)
    }
    // 添加静态resolve方法
    static resolve(value) {
        // 如果参数是MyPromise实例，直接返回这个实例
        if (value instanceof MyPromise) return value
        return new MyPromise(resolve => resolve(value))
    }
    // 添加静态reject方法
    static reject(value) {
        return new MyPromise((resolve, reject) => reject(value))
    }
    // 添加静态all方法
    static all(list) {
        return new MyPromise((resolve, reject) => {
            /**
             * 返回值的集合
             */
            let values = []
            let count = 0
            for (let [i, p] of list.entries()) {
                // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
                this.resolve(p).then(res => {
                    values[i] = res
                    count++
                    // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
                    if (count === list.length) resolve(values)
                }, err => {
                    // 有一个被rejected时返回的MyPromise状态就变成rejected
                    reject(err)
                })
            }
        })
    }
    // 添加静态race方法
    static race(list) {
        return new MyPromise((resolve, reject) => {
            for (let p of list) {
                // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
                this.resolve(p).then(res => {
                    resolve(res)
                }, err => {
                    reject(err)
                })
            }
        })
    }
    finally(cb) {
        return this.then(
            value => MyPromise.resolve(cb()).then(() => value),
            reason => MyPromise.resolve(cb()).then(() => { throw reason })
        );
    }
}






*
*
*
*
*
*
*
*
*
*



10、Async/Await 原理

 Async函数的实现原理，就是将generator函数和自动执行器，包装在一个函数里。

  async function fn(args){
      //...
  }

  // 等同于
  function fn(args){
      return spawn(function*(){

      })
  }

  所有的async函数都可以写成上面第二种形式，其中的spawn函数就是自动执行函数。


  function spawn(genF){
      return new Promise(function(resolve,reject){
            const gen = genF();
            function step(nextF){
                let next;
                try{
                    next = nextF();
                }
                catch(err){
                    return reject(err);
                }
                if(next.done){
                    return resolve(next.value);
                }
                Promise.resolve(next.value).then(function(v){
                    step(function(){
                        return gen.next(v);
                    },function(e){
                        step(function(){
                            return gen.throw(e);
                        })
                    })
                })
            }
            step(function(){
                return gen.next(undefined);
            })
      })
  }



  thunk函数值的是将执行结果传入回调函数，并将该回调函数返回的函数。

  thunk函数优势在于他能将异步操作返回结果的获取权交给thunk函数的返回值，
  而不是将异步操作结果传入thunk函数本身的作用域内，这点很重要，因为他能结合Generator语法让Generator函数自动执行。


  generator自动执行核心代码

   function run(fn){
       let gen =  fun();
       function next(err,data){
           let result = gen.next(data);
           if(result.done){
               return 
           }
           result.value(next);
       }
       next();
   }


### 概念：
    ES8 的内容
    async/await可以说就是co模块和生成器函数的语法糖。

    async用于定义一个异步函数，该函数返回一个Promise
    如果async函数返回的是一个同步的值，这个值将被包装成一个理解resolve的Promise，等同于
    return Promise.resolve();
    await用于一个异步操作之前，表示要等待这个异步操作的返回值，
   








*
*
*
*
*
*
*
*
*
*
## 11、防抖/节流原理  *******************************************************

###  缘由

在使用resize、scroll、mousemove等等事件时，会持续触发事件


### 防抖  

   防抖就是指触发事件后在n秒内函数只能执行一次，如果n秒内又触发了事件，则会重新计算函数执行时间。
   

   防抖函执行分为非立即执行和立即执行。


   非立即执行：
   function debouce(func,wait){
       let timeout;
       return function(){
           let context = this;
           let args = arguments;
           if(timeout){
               clearTimeout(timeout);
           }
           timeout = setTimeout(function(){
             func.apply(context,args);
           },wait)
       }
   }


   立即执行：

   function debouce(func,wait){
       let timeout;
       return function(){
           let context = this;
           let args = arguments;
           if(timeout){
               clearTimeout(timeout);
           }
           var callNow = !timeout;
           timeout = setTimeout(function(){
             func.apply(context,args);
           },wait)

           if(callNow){
               func.apply(context,args);
           }
       }
   }


   ### 节流

   节流就是指触发事件但是在n秒内只执行一次函数。节流会稀释函数的执行频率。


  时间戳：
  function throttle(func,wait){
      var previous = 0;
      return function(){
          let now = Date.now();
          let context = this;
          var args = arguments;
          if(now-previous>wait){
              func.apply(context,args);
              previous = now;
          }
      }
  }


  function throttle(func,wait){
      let timeout;
      return function(){
          let context = this;
          let args = arguments;
          if(!timeout){
            setTimeout(function(){
                 timeout = null;
                 func.apply(context,args);      
            },wait)
          }
      }
  }



 
## 12、模块化详解 *******************************************************


### AMD

ADM，Asynchtonous Module Definition，异步模块定义。他是一个浏览器端模块化开发规范。
他不是原生支持的，所以使用AMD规范进行页面开发需要对应的库，也就是requireJS，AMD
在推广的过程中对模块定义的范围话的产生

#### require
  用来引入模块的函数
  1、解决js文件存在依赖关系时，被依赖的文件需要早于依赖他的文件加载到浏览器；
  2、js加载的时候浏览器会阻塞渲染线程，加载文件越多，页面失去响应的时间越长。

#### define
用来定义模块的函数


### CMD
 CMD，common Module Definition，通用模块定义。CMD是在sea.js推广过程中产生的。在CMD规范中，一个模块就是一个文件。



 ### Commonjs 

 Nodejs是Commonjs规范的只要时间者。他有四个重要环境变量为模块化的实现提供支持：
 module、export、require、global。
 module.exports(不推荐使用exports)定义对外输出的API
 require引用模块

 
 #### 模块引用

 const fs  = require("fs");
 
 步骤：
 1、如果是核心模块，如fs，则直接返回模块；
 
 2、如果是路径，则拼接成一个绝对路径，然后继续读取缓存require.cache再读取文件

 3、首次加载后的模块会在require.cache中，所以多次require，得到的对象是同一个对象（引用对象）

 4、在执行模块代码的时候，会将模块包装成一下模式，以便于作用域在模块范围之内

 (function(exports,require,__filename,__dirname){
    // Module
 });

 5、包装之后的代码通过vm原生代码块的runThisContext()方法执行类，返回一个function对象。最后得到当前模块对象
 的exports、require方法、module以及文件定位中得到的完整文件路径和文件目录传递微这个函数执行。


#### 模块定义

function fn(){

}
exports.propName =  fn;

module.exports = fn;


一个module对象代表模块本身，exports是module的属性。一般通过exports上挂载属性即可定义导出，也可以直接给module.exports
赋值来定义导出


#### 模块标识
    模块标识就是传递给require()方法的参数，可以是相对路径或者绝对路径，也可以是符合小驼峰命名的字符串。



### ES6模块








*
*
*
*
*
*
*
*
*
*
13、ES6 重难点



*
*
*
*
*
*
*
*
*
*
14、计算机网络概述
*
*
*
*
*
*
*
*
*
*


## 15、浏览器渲染原理

 1、浏览器会解析Html/SVG/XHTML,CSS,javascript
   分别生成DOM Tree，CSS规则树，通过DOM API 和CSSOM API来操作 DOM Tree 和CSS Rule Tree

 2、解析完成之后就是通过DOM API 和CSSOM API 来操作DOM Tree 和CSS Rule Tree.

 3、最终通过调用操作系统Native GUI的API绘制


 





*
*
*
*
*
*
*
*
*
*
16、webpack 配置
*
*
*
*
*
*
*
*
*
*
17、webpack 原理
*
*
*
*
*
*
*
*
*
*
18、前端监控
*
*
*
*
*
*
*
*
*
*
19、跨域和安全
*
*
*
*
*
*
*
*
*
*
20、性能优化
*
*
*
*
*
*
*
*
*
*
21、VirtualDom 原理


*
*
*
*
*
*
*
*
*
*
22、Diff 算法
*
*
*
*
*
*
*
*
*
*
## 23、MVVM 双向绑定
 
 ### 实现数据绑定的几种方式

 1、发布者-订阅者模式(backbone.js)
     一般通过sub、pub的方式实现数据和视图的的绑定监听，更新数据方式通常做法式vm.set('property',value)


 2、脏值检测(angular.js)
      通过脏值检测的方式对比数据是否有变更，来决定是否更新视图，最简单的方式是通过setInterval()定时轮训
      检测数据变动，当然Google不会这么low，angular只有在指定的时间触发时进入脏值检测，大如下：
      a、DOM事件，譬如用户输入文本，点击按钮等;
      b、XHR响应事件($http);
      c、浏览器Location变更事件($location);
      d、Timer事件($timeout,$interval);
      e、执行$digest()或$apply();

 3、数据劫持(vue.js)

    vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过object.defineProperty()来劫持各个属性的setter，getter，在数据变更时发布消息给订阅者，触发相应的监听回调。



   ### 实现思路
     1、实现一个数据监听的器Observer，能够对数据对象的所有属性进行监听，如果变动可得到最新值并通知订阅者；
     2、实现一个指令解析器Compile，对每一个元素节点的指令进行扫描和解析，根据执行模板替换数据，以及绑定
        相应的更新函数；
     3、实现一个Watcher，作为Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令的响应回调函数；
     4、mvvm入口函数




   ### 1、实现observer

  var data = {name:"kebi"};
  observe(data);
  data.name = 'qiaodan';

  function observe(data){
      if(!data||typeof data !== 'object'){
          return ;
      }
      // 取出所有属性遍历
      Object.keys(data).forEach(function(key){
            defineReactive(data,key,data[key]);
      });
  }

  function defineReactive(data,key,val){
      var dep = new Dep();
      observe(val);// 监听子属性
      Object.defineProperty(data,key,{
          enumerable:true,
          configurable: true,
          get:function(){
              <!-- return val; -->
              Dep.target && dep.addDep(Dep.target);
              return val;
          },
          set:function(newVal){
              if(val===newVal) return;
              val = newVal;
              dep.notify(); // 通知订阅者
          }
      })
  }


  function Dep(){
       this.subs = [];
  }

  Dep.prototype  = {
      addSub:function(sub){
          this.subs.push(sub);
      },
      notify:function(){
          this.subs.forEach(function(sub){ 
               sub.update();
          })
      }
  }

   //Watcher
Wtacher.propertype = {
    get:function(key){
        Dep.target = this;
        this.value = data[key]; //这里会触发属性的getter，从而添加订阅者
        Dep.target = null;
    }
}


### 实现Compile

    compile主要的事情是解析模板指令，讲模板中的变量替换成数据，然后初始化渲染页面视图层，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，跟新视图

    function Compile(el){
        this.$el = this.isElementNode(el)?el:documnet.querySeleccter(el);
        if(this.$el){
            this.$fragment = this.node2Fragment(this.$el);
            this.init();
            this.$el.appendChild(this.$fragment);
        }
    }

    Compile.prototype = {
        init:function(){
            this.compileElement(this.$fragment);
        }
        node2Fragment:function(el){
            var fragment = document.createDocumentFragment(),child;
            // 将原生节点拷贝到fragment
            while(child=el.firstChild){
                fragment.appendChild(child);
            }
            return fragment;
        }
    }




 



*
*
*
*
*
*
*
*
*
*
## 24、Vuex 原理
### 概念
vuex是vue的状态管理器。
### 优点
使用vuex可以使得数据流变得清晰、可追踪、可预测，更可以简单的实现类似时光穿梭等高级功能。
对于大型应用来讲，vuex讲变得尤为重要，对于store的切分、store的module化、store的变更、
store的追踪等等store的管理工作，是vuex管理store会大大提高项目的稳定性，扩展性。
### 构成
vuex引入State、getter的概念对状态进行定义；使用Mutation和Action对状态进行该更；引入Module
对状态进行模块化分割；引入插件对状态进行快照、记录、、以及追踪等；提供了mapState、mapGeeter、
mapActions、mapMutations辅助函数方便开发者在vm中处理store。

### 使用

Vue.use(Vuex);
//1、vue的插件机制，安vuex
let store = new Vuex.Store({
    //2、实例化store，调用install方法
    state,
    getters,
    setters,
    mutations,
    actions,
    plugins
})


new Vue({
    store,
    render: h =>h(app)
}).$mount("#app);



### vue生命周期

vueInit   install->aoolyMinxin->vueInt

beforeCreate

created

beforeMount

mounted

beforeUpdate

updated

beforeDestroy

destroyed


### 结论
vuex利用了vue的minxin机制，混合了beforeCreate钩子将store注入至vue组件实例上，并注册了vuex store 的引用属性 $store






*
*
*
*
*
*
*
*
*
*
## 25、Redux 原理

### 原理

redux是继承自flux体系，但它放弃了dispatcher，无需使用event emitters（事件发送器）（在dispatcher中特定的action逻辑里触发事件，组件里监听事件），而使用单纯的reducer来代替



在调用createStore函数生成store时传入这个reducer，后继调用store的dispatch方法来触发action时，则reducer函数会自动被调用来解析action更新state，这一切的核心都在createStore

### 源码实现

export default function createStore(reducer,preloadedState,enhancer){
    ...
        let currentReducer = reducer
    let currentState = preloadedState
    let currentListeners = []
    let nextListeners = currentListeners
    let isDispatching = false
    
    function getState(){

    }

    function subscribe(listener){

    }

    function replaceReducer(nextReducer){
         
    }

    function observable(){

    }

    return  {
        disapatch,
        subscribe,
        getState,
        replaceReducer,
        [$$observable]: observable
    }
  
}

可以看到createStore方法返回一个属性集合，我们所调用的redux的相关方法都是定义在createStore方法内部，最后被通过这个属性集合暴露出来，如处理action的dispatch方法，同currentReducer，currentState是createStore方法中的私有变量，由dispatch，subscribe，getState等方法共享，我们设置的reducer，redux的state状态，以及state改变之后应该自动触发哪些函数，这些逻辑都是通过这几个内部变量和函数来实现的，


### dispatch处理action

function dispatch(action){
    ...
    try{
        // 将flag属性设置为true,表明处于分发逻辑中
        isDispatching = true
        // currentReducer即为函入的reducer函数，并将返回值赋给currentState
         currentState =  currentReducer(currentState,action);
    }
    finally{
       isDispatching = false;
    }

    // 调用监听函数
    const listener = (currentListener = nextListener)

    for(let i = 0;i<listeners.length;i++){
          const listener = listeners[i];
          listener();
    }

  return action;

}


可以看到，在dispatch中调用reducer方法处理action之后，返回值（新的state）会直接赋值给currentState，由此可以推测currentState应该就是getState要返回的状态


### getState返回当前的状态

function getState(){
    if(isDispatching){
        throw new Error(
            ...
        )
    }
    return currentState;// 直接返回currentState内部变量
}


### subscribe订阅状态

function subscribe(listener){
    if(type listener != 'function){
        throw new Error(
            ...
        )
    }
    if(isDispatching){
        throw new Error(
            ...
        )
    }
   
    let isSubscribed  =true;

    ...

    nextListeners.push(listener);

    return function unsubscribe(){

    }

}


在subscribe中，传入的listener函数会被添加进nextListener数组中，当dispatch方法被调用时自动触发，react-redux的状态更新时，UI自动更新的特性是通过subscribe来实现的








*
*
*
*
*
*
*
*
*
*
## 26、路由原理


https://juejin.im/post/5d469f1e5188254e1c49ae78
 
 ### 前言

 前端三大框架Angular、React、Vue，他们的路由解决方案angular/router、react-router、vue-router都是基于前端路由原理进行封装实现的。


 ### 路由

 优点：安全性好，SEO好
 缺点：加大服务器的压力，不利于用户体验，代码冗合不好维护


 ### 前端路由方案：

 Hash

 History


 前端路由缺陷：使用浏览器的前进，后退键时会重新发送请求，来获取数据，没有合理地利用缓存。



### Hash模式

#### 1、原理

早期的前端路由的实现就是基于location.hash来实现的。其实现原理也很简单，loacation.hash的值就是URL中#后面的内容，


#### 2、特性：

a、URL中的hash只是顾客端的一种状态，也就是说向服务器端发出的请求时，hash部分不会被发送；


b、hash值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回撤，前进按钮控制hash的切换；


c、我们可以hashchange事件监听hash的改变；



#### 3、实现
  我们先定一个BaseRouter，用于实现hash路由和History路由的一些共有的方法；

  export class BaseRouter{
      // list表示路由表
      constructor(list){
          this.list =
      }
  }








*
*
*
*
*
*
*
*
*
*
27、VueRouter 源码解析
*
*
*
*
*
*
*
*
*
*
28、ReactRouter 源码解析
*
*
*
*
*
*
*
*
*
*