# 前端高级进阶

##  1、调用堆栈  *******************************************************

执行上下文就是当前javascript代码被解析和执行是所在环境的抽象概念，
javascript中运行任何代码都是在执行上下文中运行的。
a、全局上下文
b、函数执行上下文
c、Eval函数执行上下文

执行栈，也叫调用栈，具有LIFO(Last In First Out)结构，用于存储在代码执行期间创建的所有执行上下文；

当javascript引擎首次读取脚本时，会创建一个全局执行上下文并将其Push到当前执行栈中。每当发生函数调用
时，引擎就会为该函数创建一个新的执行上下文并push到当前执行栈的栈顶；

引擎会运行执行上下文在执行栈栈顶的函数，根据LIFO规则，当前函数运行完成后，其对应的执行上下文将会从执行栈中
pop出，上下文控制权转到当前执行栈的下一个执行上下文；

 



## 2、作用域闭包  ******************************************************

### 概念
 函数与对其状态即词法环境的应用共同构成闭包(closure)。也就是说，闭包可以让你从内部函数访问外部函数作用域
。在javascript，函数在每次创建是生成闭包





## 3、this 全面解析 *******************************************************

### 前言
this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

### 总结
函数被调用时发生this绑定，this指向什么完全取决于函数在哪里被调用。

### this的绑定规则

1、默认绑定
 
 独立函数调用：独立函数调用时的this使用默认绑定规则，默认绑定规则下的this指向window(全局对象)
 严格模式：this无法使用默认绑定，this会绑定undefined


2、隐式绑定

当函数引用有上下文对象的时，隐式绑定规则会把函数中的this绑定到这个上下文对象

 var obj = {
     name:"xixi",
     foo:function(){
         console.log(this.name)
     }
 }

obj.foo();

对象属性引用链中只有上一层或者说最后一层在再调用中起作用

obj.obj1.foo();

 var obj = {
     name:"xixi",
     obj1:{
         name:"wenwen",
         foo:function(){
            console.log(this.name)
        }
     }
 }

隐式丢失： 被隐式绑定的函数会丢失绑定对象，而应用默认绑定，把this绑定到全局对象或者undefined(严格模式)上。


 
var a = "global";
var obj = {
    a:"obj",
    foo:function(){
        console.log(this.a);//global
    }
}
var bar = obj.foo;//函数别名
bar(); 


 
 var a = "global";
 var obj = {
     a: "obj",
     foo:function(){
         console.log(this.a);//global
     }
 }
var bar = obj.foo;//函数别名
function doFoo(fn){
    fn();
}
doFoo(bar); //global

setTimeout(obj.foo,3000)

3、显示绑定

通过call()和apply()方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this上，称之为显示绑定

4、new绑定
使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
 创建（或者说构造）一个新的对象
 这个新的对象被执行[[原型]]链接
 这个新对象会绑定到函数调用的this
 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象


 5、箭头函数绑定
    箭头函数绑定无法修改，new也不行


优先级：
箭头函数>new > call/apply > 隐式 > 默认


### new源码实现
    function create(){
        // 创建一个空的对象
        var obj = new Object();
        //获得构造函数，arguments中去掉第一个参数
        Con = [].shift.call(arguments);
        //  链接到原型，obj可以访问到构造函数原型中的属性
        obj.__proto__ = Con.prototype;
        // 绑定this实现继承，obj可以访问到构造函数的属性
        var ret =  Con.apply(obj,arguments);
        // 优先返回构造函数返回的对象；
        return ret instanceof Object ? ret: obj;
    }




## 4、深浅拷贝原理 *******************************************************
### 浅拷贝
只拷贝对象的基本类型值，并不复杂引用类型的值而是引用他的指针，
var a = {
    name: 12
}
var b = a;
b只是引用a的指针


### 深拷贝
深拷贝可以拥有一个对象所有属性和方法，实现真正的"独立自主"，不引用原来对
象的指针，开辟新的内存空间，和原来的对象不会相互影响


### 浅拷贝实现方法

  1、Object.assign();

   拷贝的只是属性值,只实现第一层的深拷贝，而不能进行深层的深拷贝，所以这个方法属于浅拷贝

  2、Object.create();
   这个方法创建了一个新的对象，使用现有的对象来提供新创建的对象的__proto__，实际上是地址引用，


   3、扩展运算符等
   let a = [1,2,3];
   let b = [...a];
   
   只是基于基本类型值的引用，并没有开辟新的空间

   


  ### 深拷贝实现方法

 1、JSON.parse(JSON.stringify(obj));

 

 2、利用递归的方法和for in遍历属性进行深拷贝

 function deepCopy(initialObj,copyObj){
     var obj =  copy||{};
     for(let i in initialObj){
         var prop = initialObj[i];
         if(typeof prop ==="obj"){
             obj[i] = prop.constructor===Array?[]:{},
             deepCopy(prop,obj[i]);
         }
         else{
             obj[i] = prop;
         }
     }
     return obj;
 }




## 5、原型 Prototype  

### 基本概念
每个函数都有一个prototype属性。
此属性是一个指针，能够指向一个对象，而且对象将会被构造函数创建的对象实例所共享，也就是会继承此对象
### 总结:
prototype所指向的对象是被构造函数所创建的对象实例所共用共享的。
创建的对象实例有一个内部属性[[Prototype]]，他是一个指针，指向函数原型(prototype)指向的对象。

### 构造函数 
constructor返回创建构造函数实例对象时构造函数的引用。
此属性值是对函数本身的引用，而不是一个包含函数名的字符串

 构造函数本身就是一个函数，与普通函数没有任何区别，不过为了规范一般将首字母大写

 ### Symbol
   是基本数据类型，但作为构造函数的来说并不完整，因为他不支持new Symbol

 
 ### construtor
   属性值是可以修改的，当时对于基本类型来说是只读的

### 原型链
   每一个对象都有一个原型对象，通过__proto__ 指针指向上一个原型，并从中继承属性和方法，同时原型对象也可能拥有原型，这样一层一层，最终指向null。这种关系被称为原型链，通过原型链一个对象会拥有定义在其他对象中的属性和方法









## 6、高阶函数  *******************************************************
   
   ### 高级函数
   参数或者是函数返回值是函数的函数。

   ### AOP面向切片编程
   1、当需要使用某个公共函数时需要这个函数执行前添加自己的逻辑，
   2、通常我们的做法不能是直接修改这个函数；
   3、而是通过AOP的方法利用高级函数和原型链的特点处理


   function say(name){
       console.log(name)
   }

   function before(){
       console.log("say前执行");
   }

   Function.prototype.beforeFn = function(){
       return (...argd)=>{
           before();
           this(...args);
       }
   }

   let beforeSay = say.beforeFn(before);

   beforeSay("xixi")


  ### 柯里化
   函数柯里化又叫分布求值，维基百科中对柯里化的定义：
   在数学和计算机科学中，合理化是一种讲使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受剩余的参数而且返回结果的新函数的技术。


   





## 7、事件机制 *******************************************************
   ### 事件
   文档或者浏览器窗口中发生的一些特定的交互瞬间，js和html的交互就是通过事件来实现的。
   可以使用监听器（或者处理程序）来预定事件，以便事件发生时执行相应的代码。

   ###  事件流
   描述的是从页面中接收事件的顺序。但是IE跟Netscape提出了差不多的完全相反的概念。IE
   的事件流式事件冒泡流，Netscape的事件流是事件捕获流。

   ### 事件冒泡
   IE的事件流叫事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点。

   ### 事件捕获
   Netscape提出了另一个事件流叫事件捕获。事件捕获的用意在于在事件达到预定目标之前捕获他




## 8、Event Loop 原理  
 
 ### 概念
 Event Loop 即事件循环，是指浏览器或Node的一种解决javascript单线程运行时不会阻塞的一种
 机制，也就时我们经常使用异步的理由。

### 堆
堆是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种是大堆，一种是小堆，
将根节点最大的堆叫最大堆或者大跟堆，根节点是最小的堆叫做最小堆或者小根堆。堆是线性数据结构，
相当于一维数组，有唯一后继。

### 栈
栈在计算机中是限定仅在表尾进行插入或者删除操作的线性表。栈是一种数据结构，他按照后进先出的
原则储存数据，先进的数据被压入栈底，最后的数据在栈顶，需要读取数据的时候从栈顶开始弹出数据。
栈是只能在某一端插入和删除的特殊线性表。

### 队列
只允许在表的前端(front)进行删除操作，而在后端的(rear)进行插入操作，和栈一样，队列是一种
受限的线性表


*
*
*
*
*
*
*
*
*
*


  



## 9、Promise 原理


### 1、基本结构
new Promise((resolve,reject)=>{
       setTimeout(()=>{
           resolve("FULFiLLED)
       })
})


构造函数promise必须接受一个函数作为参数，我们称该函数为handle，handle有包含resolve和reject两个参数，他们是两个函数。


定义一个判断一个变量是否为函数的方法，后面会用到

const isFunction = variable => typeof variable==== 'function';


首先，我么定义一个名为MyPromise的Class，他接受一个函数handle作为参数


class MyPromise{
    construtor(handle){
        if(!isFunction(handle){
            throw new Error("MyPromise must accept a function as parameter");
        })
    }
}


### 2、状态和值

Promise对象存在以下三种状态：


1、Pending 进行中

2、Fulfilled 已成功

3、Rejected 已失败

状态只会由Pending变成Fulfilled或者由Pending变成Rejected，而且状态改变之后不会再发生变化，会一直保持这个状态。


Promise的值是指状态改变时传递给回调函数的值


上文中handle函数包含resolve和reject两个参数，可以用于改变Promise的状态和传入Promise的值

new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve('FULFilled');
    },1000)
})



这里resolve传入的"FulFilled"就是Promise的值



resolve和reject


1、resolve：将Promise对象的状态从Pending变为Fulfilled

2、reject：将Promise对象的状态从Pending变为Rejected

3、resolve和reject都可以传入任意类型的值作为参数，表示Promise对象成功Fulfilled和失败Rejected



### 3、Promise的then方法


 promise.then(onFulfilled,onRejected);

 

 ### 完整源码

// 判断变量否为function
const isFunction = variable => typeof variable === 'function'
// 定义Promise的三种状态常量
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
    constructor(handle) {
        if (!isFunction(handle)) {
            throw new Error('MyPromise must accept a function as a parameter')
        }
        // 添加状态
        this._status = PENDING
        // 添加状态
        this._value = undefined
        // 添加成功回调函数队列
            this._reject(err)
        }
    }
    // 添加resovle时执行的函数
    _resolve(val) { 
        const run = () => {
            if (this._status !== PENDING) return
            this._status  = FULFILLED
            // 依次执行成功队列中的函数，并清空队列
            const runFulfilled = (value) => {
                let cb;
                while (cb = this._fulfilledQueues.shift()) {
                    cb(value)
                }
       
            /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
            */
            if (val instanceof MyPromise) {
                val.then(value => {
                    this._value = value
                    runFulfilled(value)
                }, err => {
                    this._value = err
                    runRejected(err)
                })
            } else {
                this._value = val
                runFulfilled(val)
            }
        }
        // 为了支持同步的Promise，这里采用异步调用
        setTimeout(run, 0)
    }
    // 添加reject时执行的函数
    _reject(err) {
        if (this._status !== PENDING) return
        // 依次执行失败队列中的函数，并清空队列
        const run = () => {
            this._status = REJECTED
            this._value = err
            let cb;
            while (cb = this._rejectedQueues.shift()) {
                cb(err)
            }
        }
        // 为了支持同步的Promise，这里采用异步调用
        setTimeout(run, 0)
    }
    // 添加then方法
    then(onFulfilled, onRejected) {
        const { _value, _status } = this
        // 返回一个新的Promise对象
        return new MyPromise((onFulfilledNext, onRejectedNext) => {
            // 封装一个成功时执行的函数
            let fulfilled = value => {
                try {
                    if (!isFunction(onFulfilled)) {
                        onFulfilledNext(value)
                    } else {
                        let res = onFulfilled(value);
                        if (res instanceof MyPromise) {
                            // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                            res.then(onFulfilledNext, onRejectedNext)
                        } else {
                            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                            onFulfilledNext(res)
                        }
                    }
                } catch (err) {
                    // 如果函数执行出错，新的Promise对象的状态为失败
                    onRejectedNext(err)
                }
            }
            // 封装一个失败时执行的函数
            let rejected = error => {
                try {
                    if (!isFunction(onRejected)) {
                        onRejectedNext(error)
                    } else {
                        let res = onRejected(error);
                        if (res instanceof MyPromise) {
                            // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                            res.then(onFulfilledNext, onRejectedNext)
                        } else {
                            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                            onFulfilledNext(res)
                        }
                    }
                } catch (err) {
                    // 如果函数执行出错，新的Promise对象的状态为失败
                    onRejectedNext(err)
                }
            }
            switch (_status) {
                // 当状态为pending时，将then方法回调函数加入执行队列等待执行
                case PENDING:
                    this._fulfilledQueues.push(fulfilled)
                    this._rejectedQueues.push(rejected)
                    break
                // 当状态已经改变时，立即执行对应的回调函数
                case FULFILLED:
                    fulfilled(_value)
                    break
                case REJECTED:
                    rejected(_value)
                    break
            }
        })
    }
    // 添加catch方法
    catch(onRejected) {
        return this.then(undefined, onRejected)
    }
    // 添加静态resolve方法
    static resolve(value) {
        // 如果参数是MyPromise实例，直接返回这个实例
        if (value instanceof MyPromise) return value
        return new MyPromise(resolve => resolve(value))
    }
    // 添加静态reject方法
    static reject(value) {
        return new MyPromise((resolve, reject) => reject(value))
    }
    // 添加静态all方法
    static all(list) {
        return new MyPromise((resolve, reject) => {
            /**
             * 返回值的集合
             */
            let values = []
            let count = 0
            for (let [i, p] of list.entries()) {
                // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
                this.resolve(p).then(res => {
                    values[i] = res
                    count++
                    // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
                    if (count === list.length) resolve(values)
                }, err => {
                    // 有一个被rejected时返回的MyPromise状态就变成rejected
                    reject(err)
                })
            }
        })
    }
    // 添加静态race方法
    static race(list) {
        return new MyPromise((resolve, reject) => {
            for (let p of list) {
                // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
                this.resolve(p).then(res => {
                    resolve(res)
                }, err => {
                    reject(err)
                })
            }
        })
    }
    finally(cb) {
        return this.then(
            value => MyPromise.resolve(cb()).then(() => value),
            reason => MyPromise.resolve(cb()).then(() => { throw reason })
        );
    }
}






*
*
*
*
*
*
*
*
*
*



## 10、Async/Await 原理

 Async函数的实现原理，就是将generator函数和自动执行器，包装在一个函数里。

  async function fn(args){
      //...
  }

  // 等同于
  function fn(args){
      return spawn(function*(){

      })
  }

  所有的async函数都可以写成上面第二种形式，其中的spawn函数就是自动执行函数。


  function spawn(genF){
      return new Promise(function(resolve,reject){
            const gen = genF();
            function step(nextF){
                let next;
                try{
                    next = nextF();
                }
                catch(err){
                    return reject(err);
                }
                if(next.done){
                    return resolve(next.value);
                }
                Promise.resolve(next.value).then(function(v){
                    step(function(){
                        return gen.next(v);
                    },function(e){
                        step(function(){
                            return gen.throw(e);
                        })
                    })
                })
            }
            step(function(){
                return gen.next(undefined);
            })
      })
  }



  thunk函数值的是将执行结果传入回调函数，并将该回调函数返回的函数。

  thunk函数优势在于他能将异步操作返回结果的获取权交给thunk函数的返回值，
  而不是将异步操作结果传入thunk函数本身的作用域内，这点很重要，因为他能结合Generator语法让Generator函数自动执行。


  generator自动执行核心代码

   function run(fn){
       let gen =  fun();
       function next(err,data){
           let result = gen.next(data);
           if(result.done){
               return 
           }
           result.value(next);
       }
       next();
   }


### 概念：
    ES8 的内容
    async/await可以说就是co模块和生成器函数的语法糖。

    async用于定义一个异步函数，该函数返回一个Promise
    如果async函数返回的是一个同步的值，这个值将被包装成一个理解resolve的Promise，等同于
    return Promise.resolve();
    await用于一个异步操作之前，表示要等待这个异步操作的返回值，
   



*
*
*
*
*
*
*
*
*
*
## 11、防抖/节流原理  *******************************************************

###  缘由

在使用resize、scroll、mousemove等等事件时，会持续触发事件


### 防抖  

   防抖就是指触发事件后在n秒内函数只能执行一次，如果n秒内又触发了事件，则会重新计算函数执行时间。
   

   防抖函执行分为非立即执行和立即执行。


   非立即执行：
   function debouce(func,wait){
       let timeout;
       return function(){
           let context = this;
           let args = arguments;
           if(timeout){
               clearTimeout(timeout);
           }
           timeout = setTimeout(function(){
             func.apply(context,args);
           },wait)
       }
   }


   立即执行：

   function debouce(func,wait){
       let timeout;
       return function(){
           let context = this;
           let args = arguments;
           if(timeout){
               clearTimeout(timeout);
           }
           var callNow = !timeout;
           timeout = setTimeout(function(){
             func.apply(context,args);
           },wait)

           if(callNow){
               func.apply(context,args);
           }
       }
   }


   ### 节流

   节流就是指触发事件但是在n秒内只执行一次函数。节流会稀释函数的执行频率。


  时间戳：
  function throttle(func,wait){
      var previous = 0;
      return function(){
          let now = Date.now();
          let context = this;
          var args = arguments;
          if(now-previous>wait){
              func.apply(context,args);
              previous = now;
          }
      }
  }


  function throttle(func,wait){
      let timeout;
      return function(){
          let context = this;
          let args = arguments;
          if(!timeout){
            setTimeout(function(){
                 timeout = null;
                 func.apply(context,args);      
            },wait)
          }
      }
  }



 
## 12、模块化详解 *******************************************************


### AMD

ADM，Asynchtonous Module Definition，异步模块定义。他是一个浏览器端模块化开发规范。
他不是原生支持的，所以使用AMD规范进行页面开发需要对应的库，也就是requireJS，AMD
在推广的过程中对模块定义的范围话的产生

#### require
  用来引入模块的函数
  1、解决js文件存在依赖关系时，被依赖的文件需要早于依赖他的文件加载到浏览器；
  2、js加载的时候浏览器会阻塞渲染线程，加载文件越多，页面失去响应的时间越长。

#### define
用来定义模块的函数


### CMD
 CMD，common Module Definition，通用模块定义。CMD是在sea.js推广过程中产生的。在CMD规范中，一个模块就是一个文件。



 ### Commonjs 

 Nodejs是Commonjs规范的主要实践者。他有四个重要环境变量为模块化的实现提供支持：
 module、export、require、global。
 module.exports(不推荐使用exports)定义对外输出的API
 require引用模块

 
 #### 模块引用

 const fs  = require("fs");
 
 步骤：
 1、如果是核心模块，如fs，则直接返回模块；
 
 2、如果是路径，则拼接成一个绝对路径，然后继续读取缓存require.cache再读取文件

 3、首次加载后的模块会在require.cache中，所以多次require，得到的对象是同一个对象（引用对象）

 4、在执行模块代码的时候，会将模块包装成一下模式，以便于作用域在模块范围之内

 (function(exports,require,__filename,__dirname){
    // Module
 });

 5、包装之后的代码通过vm原生代码块的runThisContext()方法执行类，返回一个function对象。最后得到当前模块对象
 的exports、require方法、module以及文件定位中得到的完整文件路径和文件目录传递微这个函数执行。


#### 模块定义

function fn(){

}
exports.propName =  fn;

module.exports = fn;


一个module对象代表模块本身，exports是module的属性。一般通过exports上挂载属性即可定义导出，也可以直接给module.exports
赋值来定义导出


#### 模块标识
    模块标识就是传递给require()方法的参数，可以是相对路径或者绝对路径，也可以是符合小驼峰命名的字符串。



### ES6模块

import、export取代了require、module.exports用来引入和导出模块

1、ES6模块输出的是值的引用，输出接口动态绑定，而CommonJS输出的是值的拷贝

2、ES6模块编译时执行，而ComonJS模块总是运行时加载








*
*
*
*
*
*
*
*
*
*
## 13、ES6 重难点

### 1、let/const

let 声明的变量只能在命令所在的代码块有效

const 一般用来声明常量，并且不可变


### 2、解构赋值



### 3、函数参数解构赋值


### 4、rest 函数参数扩展，函数默认参数


### 5、箭头函数

箭头函数没有自己的this，都是继承而来


### 6、数组、对象扩展


### 7、promise

### 8、class


### 9、set/map

### 10、async


### 11、模块化详解






*
*
*
*
*
*
*
*
*
*
## 14、计算机网络概述
   https://juejin.im/post/5d896cccf265da03bd055c87

  ### 1、五层网络协议体系结构
    1、应用层
    
      协议：
        超文本传输协议  HTTP
        文件传输协议  FTP
        简单路由传输协议 SMTP
        域名系统 DNS
        安全外壳协议 DHCP
        远程登录协议  TELNET


    2、运输层

    传输控制协议 TCP
    用户数据报文协议 UDP

    3、网络层
       网际协议 IP
       地址转换协议 ARP
       反向地址转换协议 RARP
       internet控制报文协议 ICMP
       internet组管理协议 IGMP
       分布式链路状态协议 OSPF
       边界网关协议 BGP
   


    4、数据链路层

     自动重传请求协议ARQ
     停止等待协议 CSMA/CD

    5、物理层

    中继器
    集线器
    网线
    HUB






*
*
*
*
*
*
*
*
*
*


## 15、浏览器渲染原理

 1、浏览器会解析Html/SVG/XHTML,CSS,javascript
   分别生成DOM Tree，CSS规则树，通过DOM API 和CSSOM API来操作 DOM Tree 和CSS Rule Tree

 2、解析完成之后就是通过DOM API 和CSSOM API 来操作DOM Tree 和CSS Rule Tree.

 3、最终通过调用操作系统Native GUI的API绘制


 





*
*
*
*
*
*
*
*
*
*
## 16、webpack 配置

webpack给前端开发带来了毋庸置疑的变化，它把JS，图片，css都作为模块处理，同时具有开发便捷，自动化，兼容AMD写法等等诸多无需赘述的有点，更令人称道的是其插件社区非常强大，对于不同的业务需求和技术需求社区都有大量插件可供使用

### 需求
1、打包调试
2、提取公共代码
3、压缩
4、热替换


### 1、打包调试
第一步，我们在目标文件夹下安装webpack

npm install webpack@ -g 

cmpm install webpack@ --save-dev
我们将编写的js代码和样式文件放置在app文件夹内

第二步，我们在目标文件夹下新建webpackconfig.js文件

module.exports  = {
  entry:{
      main:___dirname+"/app/main.js"
  },
  output:{
      path:__dirname+"/public",
      filename:"[name].[id].js",
      publicPath: '/public/'

  }
}

我们已经完成了webpack最基础部分：添加文件的输入输出。入口是app文件夹内的main.js文件，出口为public文件夹。接下来我们来处理各种文件的解析，就是大名鼎鼎的loader的舞台。


npm i babel-loader babel-core babel-preset-es2015 babel-preset-stage-0 --save-dev

npm i less less-loader css-loader style-loader --save-dev
 


### 2、提取公共代码

引入CommonChunkPlugin插件，在webpack.config.js添加如下内容：

module.exports = {
    devtool:'cheap-module-eval-source-map',
    entry:{
        main:__dirname+'/app/main.js',,
        vender:'moment'
    }
    output:{
        path:__dirname+'/public',
        filename:'[name].[id].js',
        publicPath:'/public/'
    },
    module:{

    },
    pulgins:[

    ]
}

### 3、压缩
在webpack中，图片，css，js等等其他资源皆可压缩，js压缩：

安装插件：

npm install uglifyjs-webpack-plugin --save-dev

在webpack.config.js中引入：

var UglifyJSPlugin = require("uglifyjs-webpack-plugin");

new UglifyJSPlugin({
    beautify:true,
    exclude:['/node_module/'],
    compress:{
        warning:false
    },
    output:{
        comments:false
    }
})
我们指定了压缩的方法，排除了不需要压缩的node_module部分，同时我们去除了comment部分。再次在终端输入打包指令，可见js打包后的体积有令人满意的减小


### 4、热替换
热替换有两种方式，cli和node。cli方法无需添加新的热替换插件，且无需在入口处添加webpack-dev-server等入口

在webpack.config.js中添加devServer字段，加入如下代码:
devServer:{
    inline:true,
    hot:true
},

保存后运行

webpack-dev-server --inline --hot --progress



### 5、运行

我们知道，每次打包后，都会有新的main.js文件生成，其hash值每次打包后都会发生变化，难道我们的index.html文件需要每次打包后都手动修改main.js的路径吗？还好社区提供了html-webpack-plugin插件，可以在已有HTML模板的条件下自动为我们生成带有最新代码的hmtl文件：
npm install html-webpack-plugin --save -dev


在webpackconfig.js中引入

var HtmlWebpackPlugin = require('html-webpack-plugin');

new HtmlWebpackPlugin({
    title:"demo",
    template:"index.html"
})




*
*
*
*
*
*
*
*
*
*
## 17、webpack 原理

 ### 基本概念
 1、Entry：入口，Webpack执行构建的第一步将从Entry开始，可以抽象输入；
 
 2、Module：模块，在Webpack里一切皆模块，一个模块对应着一个文件。Webpack会从配置的Entry开始递归找出所有依赖的模块

3、Chunk：代码块，一个Chunk由多个模块组合而成，用于代码合并与分割

4、loader：模块模拟器，用于模块把原内容按照需求转换成新内容

5、Plugin：扩展插件，在Webpack构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在待定时机做对应的事情


### 流程

1、初始化参数：从配置文件和shell语句中读取与合并参数，得出最终的参数；

2、开始编译: 用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译；

3、确定入口：根据配置中的entry找出所有的入口文件

4、编译模块：从入口文件出发，调用所有配置的Loader对模块进行编译，再找出该模块依赖的模块，再递归本步骤知道所有入口依赖的文件都经过了本步骤处理；

5、完成模块编译：在经过第4步使用Loader翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系

6.输出资源：根据入口和模块之家的依赖关系，组装成一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会

7、输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。






*
*
*
*
*
*
*
*
*
*
## 18、前端监控
   

*
*
*
*
*
*
*
*
*
*
## 19、跨域和安全


*
*
*
*
*
*
*
*
*
*
## 20、性能优化

1、资源合并与压缩

a、减少http请求
b、减小请求的大小


2、懒加载与预加载

懒加载
a、图片进入可视区域之后请求图片资源

b、对于电商等图片很多，页面很长的业务场景使用

c、减少无效资源的加载

d、并发加载的资源过多会堵塞js的加载，影响网站的正常使用

预加载

a、图片等静态资源在使用之前提前请求

b、资源使用到时能从缓存中加载，提升用户体验

c、页面展示的依赖关系维护


### 重绘&回流

#### 回流
1、当render tree中的一部分因为元素的规模尺寸，布局，隐藏等改变二需要重新构建。这就是回流

2、当页面布局和几何属性改变时，需要回流



#### 重绘
1、当render tree中的一些元素需要更新的属性，而这些属性只是影响元素的外观，风格，而不是影响布局，比如backgroun-color。就称重绘







*
*
*
*
*
*
*
*
*
*
## 21、VirtualDom 原理


*
*
*
*
*
*
*
*
*
*
## 22、Diff 算法



*
*
*
*
*
*
*
*
*
*
## 23、MVVM 双向绑定
 
 ### 实现数据绑定的几种方式

 1、发布者-订阅者模式(backbone.js)
     一般通过sub、pub的方式实现数据和视图的的绑定监听，更新数据方式通常做法式vm.set('property',value)



 2、脏值检测(angular.js)
      通过脏值检测的方式对比数据是否有变更，来决定是否更新视图，最简单的方式是通过setInterval()定时轮训
      检测数据变动，当然Google不会这么low，angular只有在指定的时间触发时进入脏值检测，大如下：
      a、DOM事件，譬如用户输入文本，点击按钮等;
      b、XHR响应事件($http);
      c、浏览器Location变更事件($location);
      d、Timer事件($timeout,$interval);
      e、执行$digest()或$apply();



 3、数据劫持(vue.js)

    vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过object.defineProperty()来劫持各个属性的setter，getter，在数据变更时发布消息给订阅者，触发相应的监听回调。



   ### 实现思路
     1、实现一个数据监听的器Observer，能够对数据对象的所有属性进行监听，如果变动可得到最新值并通知订阅者；
     2、实现一个指令解析器Compile，对每一个元素节点的指令进行扫描和解析，根据执行模板替换数据，以及绑定
        相应的更新函数；
     3、实现一个Watcher，作为Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令的响应回调函数；
     4、mvvm入口函数




   ### 1、实现observer

  var data = {name:"kebi"};
  observe(data);
  data.name = 'qiaodan';

  function observe(data){
      if(!data||typeof data !== 'object'){
          return ;
      }
      // 取出所有属性遍历
      Object.keys(data).forEach(function(key){
            defineReactive(data,key,data[key]);
      });
  }

  function defineReactive(data,key,val){
      var dep = new Dep();
      observe(val);// 监听子属性
      Object.defineProperty(data,key,{
          enumerable:true,
          configurable: true,
          get:function(){
              <!-- return val; -->
              Dep.target && dep.addDep(Dep.target);
              return val;
          },
          set:function(newVal){
              if(val===newVal) return;
              val = newVal;
              dep.notify(); // 通知订阅者
          }
      })
  }


  function Dep(){
       this.subs = [];
  }

  Dep.prototype  = {
      addSub:function(sub){
          this.subs.push(sub);
      },
      notify:function(){
          this.subs.forEach(function(sub){ 
               sub.update();
          })
      }
  }

   //Watcher
Wtacher.propertype = {
    get:function(key){
        Dep.target = this;
        this.value = data[key]; //这里会触发属性的getter，从而添加订阅者
        Dep.target = null;
    }
}


### 实现Compile

    compile主要的事情是解析模板指令，讲模板中的变量替换成数据，然后初始化渲染页面视图层，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，跟新视图

    function Compile(el){
        this.$el = this.isElementNode(el)?el:documnet.querySeleccter(el);
        if(this.$el){
            this.$fragment = this.node2Fragment(this.$el);
            this.init();
            this.$el.appendChild(this.$fragment);
        }
    }

    Compile.prototype = {
        init:function(){
            this.compileElement(this.$fragment);
        }
        node2Fragment:function(el){
            var fragment = document.createDocumentFragment(),child;
            // 将原生节点拷贝到fragment
            while(child=el.firstChild){
                fragment.appendChild(child);
            }
            return fragment;
        }
    }




 



*
*
*
*
*
*
*
*
*
*
## 24、Vuex 原理
### 概念
vuex是vue的状态管理器。
### 优点
使用vuex可以使得数据流变得清晰、可追踪、可预测，更可以简单的实现类似时光穿梭等高级功能。
对于大型应用来讲，vuex讲变得尤为重要，对于store的切分、store的module化、store的变更、
store的追踪等等store的管理工作，是vuex管理store会大大提高项目的稳定性，扩展性。
### 构成
vuex引入State、getter的概念对状态进行定义；使用Mutation和Action对状态进行该更；引入Module
对状态进行模块化分割；引入插件对状态进行快照、记录、、以及追踪等；提供了mapState、mapGetter、
mapActions、mapMutations辅助函数方便开发者在vm中处理store。

### 使用

Vue.use(Vuex);
//1、vue的插件机制，安vuex
let store = new Vuex.Store({
    //2、实例化store，调用install方法
    state,
    getters,
    setters,
    mutations,
    actions,
    plugins
})


new Vue({
    store,
    render: h =>h(app)
}).$mount("#app);



### vue生命周期

vueInit   install->aoolyMinxin->vueInt

beforeCreate

created

beforeMount

mounted

beforeUpdate

updated

beforeDestroy

destroyed


### 结论
vuex利用了vue的minxin机制，混合了beforeCreate钩子将store注入至vue组件实例上，并注册了vuex store 的引用属性 $store






*
*
*
*
*
*
*
*
*
*
## 25、Redux 原理

### 原理

redux是继承自flux体系，但它放弃了dispatcher，无需使用event emitters（事件发送器）（在dispatcher中特定的action逻辑里触发事件，组件里监听事件），而使用单纯的reducer来代替



在调用createStore函数生成store时传入这个reducer，后继调用store的dispatch方法来触发action时，则reducer函数会自动被调用来解析action更新state，这一切的核心都在createStore

### 源码实现

export default function createStore(reducer,preloadedState,enhancer){
    ...
    let currentReducer = reducer
    let currentState = preloadedState
    let currentListeners = []
    let nextListeners = currentListeners
    let isDispatching = false
    
    function getState(){

    }

    function subscribe(listener){

    }

    function replaceReducer(nextReducer){
         
    }

    function observable(){

    }

    return  {
        disapatch,
        subscribe,
        getState,
        replaceReducer,
        [$$observable]: observable
    }
  
}

可以看到createStore方法返回一个属性集合，我们所调用的redux的相关方法都是定义在createStore方法内部，最后被通过这个属性集合暴露出来，如处理action的dispatch方法，同currentReducer，currentState是createStore方法中的私有变量，由dispatch，subscribe，getState等方法共享，我们设置的reducer，redux的state状态，以及state改变之后应该自动触发哪些函数，这些逻辑都是通过这几个内部变量和函数来实现的，


### dispatch处理action

function dispatch(action){
    ...
    try{
        // 将flag属性设置为true,表明处于分发逻辑中
        isDispatching = true
        // currentReducer即为函入的reducer函数，并将返回值赋给currentState
         currentState =  currentReducer(currentState,action);
    }
    finally{
       isDispatching = false;
    }

    // 调用监听函数
    const listener = (currentListener = nextListener)

    for(let i = 0;i<listeners.length;i++){
          const listener = listeners[i];
          listener();
    }

  return action;

}


可以看到，在dispatch中调用reducer方法处理action之后，返回值（新的state）会直接赋值给currentState，由此可以推测currentState应该就是getState要返回的状态


### getState返回当前的状态

function getState(){
    if(isDispatching){
        throw new Error(
            ...
        )
    }
    return currentState;// 直接返回currentState内部变量
}


### subscribe订阅状态

function subscribe(listener){
    if(type listener != 'function){
        throw new Error(
            ...
        )
    }
    if(isDispatching){
        throw new Error(
            ...
        )
    }
   
    let isSubscribed  =true;

    ...

    nextListeners.push(listener);

    return function unsubscribe(){

    }

}


在subscribe中，传入的listener函数会被添加进nextListener数组中，当dispatch方法被调用时自动触发，react-redux的状态更新时，UI自动更新的特性是通过subscribe来实现的








*
*
*
*
*
*
*
*
*
*
## 26、路由原理


https://juejin.im/post/5d469f1e5188254e1c49ae78
 
 ### 前言

 前端三大框架Angular、React、Vue，他们的路由解决方案angular/router、react-router、vue-router都是基于前端路由原理进行封装实现的。


 ### 路由

 优点：安全性好，SEO好
 缺点：加大服务器的压力，不利于用户体验，代码冗合不好维护


 ### 前端路由方案：

 Hash

 History


 前端路由缺陷：使用浏览器的前进，后退键时会重新发送请求，来获取数据，没有合理地利用缓存。



### Hash模式

#### 1、原理

早期的前端路由的实现就是基于location.hash来实现的。其实现原理也很简单，loacation.hash的值就是URL中#后面的内容，


#### 2、特性：

a、URL中的hash只是顾客端的一种状态，也就是说向服务器端发出的请求时，hash部分不会被发送；


b、hash值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回撤，前进按钮控制hash的切换；


c、我们可以hashchange事件监听hash的改变；



#### 3、实现
  我们先定一个BaseRouter，用于实现hash路由和History路由的一些共有的方法；

  export class BaseRouter{
      // list表示路由表
      constructor(list){
          this.list =list
      }

      // 页面渲染函数
      render(state){
          let ele = this.list.find(ele=>ele.path === state);
          ele = ele?ele: this.list.find(ele => ele.path === '*');
          ELEMENT.innerTEXT = ele.component;
      } 
  }

  我们简单的实现了push压入功能、go前进/后退功能，

  export class HashRouter extends BaseRouter{
       constructor(list){
           super(list);
           this.handler();
           // 监听hashchange事件
           window.addEventListener('hashchange',function(e){
               this.handler();
           })
       }
       // hash改变时，重新渲染页面

        handler(){
            this.render(this.getState());
        }

        // 获取hash值
        getState(){
            const hash = window.location.hash
            return hash ?hash.slice(1):'/'
        }

        // push 新的页面

        push(path){
            window.location.hash = path;
        }

        // 获取默认页 url

        getUrl(path){
            const href = window.location.href;
            const i = href.indexof('#');
            const base = i>0?href.slice(0,1): href;
            return base+'#'+path;
        }

        // 切换页面
        replace(path){
             window.location.replace(this.getUrl(path))
        }

        go(n){
            window.history.go(n);
        }

  }



### History模式

#### 原理

window.history.pushState(null,null,path);

window.histort.replaceState(null,null,path);


#### 实现

export class HistoryRouter extends BaseRouter{
   constructor(list){
       super(list);
       this.handler();
       // 监听popstate事件
       window.addEventListener("popstate",e=>{
            console.log('触发popstate...');
            this.handler();
       })
   }
   // 渲染页面
   handler(){
       this.render(this.getState());
   }

   // 获取url
   getState(){
       const path = window.location.pathname;
       return path?path:'/';
   }

   // push页面
   push(path){
       history.pushState(null,null,path);
       this.handler();
   }

   // replace页面
    
    replace(path){
        history.replaeState(null,nullpath);
        this.handler();
    }

    //前进or后退

    go(n){
        window.history.go(n);
    }


   

}




*
*
*
*
*
*
*
*
*
*
## 27、VueRouter 源码解析

### 路由原理
前端路由实现本质就是监听URL变化，然后匹配路由规则，显示响应的页面，并且无需刷新。目前单页面使用的路由就只有两种实现方式：
hash 模式
history 模式


www.test.com/#/yck就是hash URL，当#后面的哈希值发生改变时，不会向服务器请求数据，可以通过hashchange事件来监听到URL的变化，从而进行跳转页面


www.test.com/yck 是historyURL，是HTML5新推出的功能，比之前的Hash URL更加美观


### 源码解析

#### 路由注册

使用路由之前，需要调用Vue.use(VueRouter),这是因为让插件可以使用Vue

export function initUse(Vue: GlobalAPI){
    Vue.use = function(plugin: Function|Object){
        // 判断重复插件安装
        const installedPlugins = (this._installedPlugins|| (this._installedPlugins= []))

        if((installedPlugins.indexOf(plugin)>-1)){
            return this;
        }
       const args = toArray(arguments,1);
       // 插入Vue
       args.unshift(this);

       // 一般插件都会有一个install函数
       // 通过该函数让插件可以使用Vue
       if(typeof plugin.install==='function'){
           plugin.install.apply(plugin,args);
       }
       else if(typeof plugin === 'function'){
           plugin.apply(null,args)
       }
       installedPlugins.push(plugin);
       return this;
    
    }

}


#### install部分实现
export function install(Vue){
    // 确保install调用一次
    if(install.installed && _Vue === Vue) return 
    install.installed = true;
    // 把Vue赋值给全局变量
    _Vue = Vue
    const registerInstance = (vm,callVal)=>{
        let i = vm.$options._parentVnode
        if(isDef(i) && isDeft(i=i.data) && isDeft(i=i.registerRouteInstance)){
            i(vm,callVal)
        }
    }

    // 给每个组件的钩子函数混入实现
    // 可以发现在beforecreate钩子函数执行会初始化路由

    Vue.mixin({
        beforeCreate(){
            // 判断组件是否存在router对象，该对象只在根组件上有
            if(isDef(this.$options.router)){
                // 根据路由设置为自己
                this._routerRoot = this;
                this._router = this.$options.router;
                // 初始化路由
                this._router.init(this)
                // 很重要，为_route 属性实现双向绑定
                // 触发组件渲染
                Vue.util.defineReactive(this,'_route',this._router.history.current)
            }
            else{
           // 用于router-view层级判断
            this._routerRoot = (this.$parent && this.$parent._routerRoot) ||this
            }
             registerInstance(this,this);
        },
        destroyed(){
            registerInstance(this);
        }
    })
    Vue.component("Router",View);
    Vue.component("RouterLink",Link);

}


对于路由注册来说，核心是Vue.use(VueRouter)，使得VueRouter可以使用Vue。
然后通过Vue来调用VueRouter的install函数。在该函数中，核心就是给组件混入钩子函数和全局注册两个路由组件


#### VueRouter构造函数
constructor(options: RouterOptions = {}){
     // 路由匹配对象
     this.master = createMatcher(options.routes||[],this)

     // 根据mode采取不同的路由方式
     let mode = options.mode || 'hash'
     this.fallback = mode === 'history' && !supportPushState && options.fallback !== false

     if(this.fallback){
         mode ='hash'
     } 
     if(! inBrower){
         mode = 'abstract';
     }
     this.mode = mode;
     switch(mode){
         case 'history': 
         this.history =new HTML5History(this,options.base)
         break
         case 'hash':
        this.history = new HashHistory(this,options.base,this.fallback)
        back
        case 'abstract':
        this.history = new AbstractHistory(this,options.base)
        default:
        if(process.env.NODE_ENV !== 'production'){
            assert(false,`invalid mode:$(mode)`)
        }
     }
}

在实例化VueRouter的过程中，核心是创建一个路由匹配对象，并且根据mode来采取不同的路由方式


### 创建路由匹配对象

export function createMatcher(
    routes: Array<RouteConfig>,
    router: VueRouter
):Matcher{
    // 创建路由映射表
    const {pathList,pathMap,nameMap} = createRouteMap(routes)
    
    function addRoutes(routes){
         createRouteMap(routes,pathList,pathMap,nameMap)
    }
    // 路由匹配
    function match(
        raw: Rawlocation,
        currentRoute?:Route,
        redirectedFrom?:Location
    ):Route{
        //...
    }

   return {
       match,
       addRoutes
   }
}

createMatcher 函数的作用就是创建路由映射表，然后通过闭包的方式让addRoutes和match函数能够实用路由映射表的几个对象，最后返回一个Matcher对象


### createMatcher函数时如何创建映射表

export  function createRouteMap(
    routes: Array<RouteConfig>,
    oldPathList?:Array<string>,
    oldPathMap?:Dictionary<RouteRecord>,
    oldNameMap?:Dictionary<RouteRecord>
):{
    pathList: Array<string>;
    pathMap: Dictionary<RouteRecord>;
    nameMap: Dictionary<RouteRecord>
}
{
    // 创建映射
    const pathList : Array<string> = oldPathList||[]
    const pathMap: Dictionary<RouteRecord> = oldPathMap || Object.create(null)
    const nameMap: Dictionary<RouteRecord> = oldNameMap || Object.create(null)
    // 遍历路由配置，为每个配置添加路由记录
    routes.forEach(route=>{
        addRouteRecord(pathList,pathMap,nameMap,route)
    })
    // 确保通配符在最后
   
     for(let i=0,l= pathList.length;i<l;i++){
         if(pathList[i] === '*'){
             pathList.push(pathList.splice(i,1)[0])
             l--
             i--
         }
     }
     return {
         pathList,
         pathMap,
         nameMap
     }
}

// 添加路由记录

function addRouteRecord(
    pathList: Array<string>,
    pathMap: Dictionary<RouteRecord>,
    nameMap: Dictionary<RouteRecord>,
    route: RouteConfig,
    parent?: RouteRecord,
    matchAs?: string
){
    // 获得路由配置下的属性
    cosnt {path,name} = route;
    const pathToRegexpOptions: PathRegexpOptions = route.pathToRegexpOptions || {}

    // 格式化 url 替换/
    const normalizedPath(
        path,
        parent,
        pathToRegexpOptions.strict
    )

    // 生成记录对象
    const record:RouteRecord = {
        path:normalizedPath,
        regex:compileRouteRegex(normalizedPath,pathToRegexpOptions),
        components: route.components|| {default: route.component},
        instances:{},
        name,
        parent,
        matchAs,
        redirect: route.redirect,
        beforeEnter:route.beforeEnter,
        meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  }

  if (route.children) {
    // 递归路由配置的 children 属性，添加路由记录
    route.children.forEach(child => {
      const childMatchAs = matchAs
        ? cleanPath(`${matchAs}/${child.path}`)
        : undefined
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs)
    })
  }
  // 如果路由有别名的话
  // 给别名也添加路由记录
  if (route.alias !== undefined) {
    const aliases = Array.isArray(route.alias)
      ? route.alias
      : [route.alias]

    aliases.forEach(alias => {
      const aliasRoute = {
        path: alias,
        children: route.children
      }
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      )
    })
  }
  // 更新映射表
  if (!pathMap[record.path]) {
    pathList.push(record.path)
    pathMap[record.path] = record
  }
  // 命名路由添加记录
  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record
    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
      warn(
        false,
        `Duplicate named routes definition: ` +
        `{ name: "${name}", path: "${record.path}" }`
      )
    }
  }
}

 




*
*
*
*
*
*
*
*
*
*
## 28、ReactRouter 源码解析
   

   react-router为react提供路由管理，为基于jsx格式的app系统提供了方便切换页面功能

   它在前端提供给了两个方式，通过hashchange或者浏览器原生的history api 进行地址更新


   ### 路由配置
   react-router本身为react组件，内部组件Router,Route,IndexRoute,Redirect,Link等
   <Router history={withExampleBasename(browserHistory, __dirname)}>
    <Route path="/" component={App}>
        <IndexRoute component={Index}/>
            <Route path="/about" component={About}/>
            <Route path="users" component={Users}>
                <IndexRoute component={UsersIndex}/>
                <Route path=":id" component={User}/>
            </Route>
        </Route>
    </Router>

   ###初始化

   初始化browerhistory对象
   react-router依赖history^2.0模块生成的对象，然后在Router生命周期componentWillMount中加入对应的封装如basename，query

   useQueries.js对history对象内的方法进行封装

   function listen(listener){
       return history.listen(function(location){
           listener(addQuery(location))
       })
   }

   function push(location){
       history.push(appendQuery(location,location.query))
   }

   ### 初始化监听事件
   this._unlisten  = transitionManager.listen(function(error,state){
       if(error){
           _this.handleError(error)
       }
       else{
          _this.setState(state,_this.props.onUpdate); 
       }
   })
  
    function listen(listener){
        changeListener.push(listener);
        if(location){
            listener(location)'
        }
        else{
            var _location = getCurrentLocation();
            allKeys = [_location.key];
            updateLoation(_location)
        }
    }

   ### 改变路由

   <Link to='about' activeStyle={ACTIVE}></Link>

   1、触发Link组件的handleClick方法

   2、调用router的push方法

   3、拼装location对象

   4、改变url地址

   5、调用updateLocation触发changeListeners内的所有监听事件

   6、回调函数内调用match方法，根据location对象正则匹配router对象，匹配出对应的组件，执行runLeaveHooks钩子

   7、调用Router组件的setState(nextState);

   8、Router-context组件的render方法调用createElement

   9、调用react.createElement

   10、完成渲染


   ### 封装
    1、注册监听事件:封装history对象的,生成router对象存储在Router内,并通过其注册监听事件,绑定相应的回调函数
    2、触发监听事件:通过Link/browserHistory.push/浏览器回退快进/dom ready 等四种方式触发回调函数
    3、回调函数: Router内的setState(next)最终触发react.createElement进而更新UI












*
*
*
*
*
*
*
*
*
*