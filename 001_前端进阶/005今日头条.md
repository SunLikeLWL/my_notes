# 今日头条

## 1、对async、await的理解，内部原理

async是Generator函数的语法糖，并对Generator函数进行了改进

### 1、async的实现是将Generator函数和自动执行器，包装在一个函数里。

async function fn(args){

}

// 等同于 
function fn(args){
    return spawn(function *(){

    })
}

spawn函数时自动执行器，下面给出spawn函数的实现


function spawn(genF){
    return new Promise((resolve,reject)=>{
        const gen = genF();// 先将Generator函数执行下，拿到遍历器对象
        function step(nextF){
            let next
            try{
                next = nextF();
            }
            catch(e){
                return reject(e);
            }
            if(next.done){
                return resolve(next.value)
            }
            Promise.resolve(next.value).then((v)=>{
                step(()=>{return gen.next(v)})
            },(e)=>{
                step(()=>{
                    return gen.throw(e)
                })
            })
        }
        step(()=>{
            return gen.next(undefinex)
        })
    })
}

### 2、更好的语义

async和await，比起星号和yield，语义更加清楚，async表示函数里面有异步操作，await表示紧跟在后面的表达式需要等待结果


### 3、更广的适用性

co模块约定，yield命令后面只能是Thunk函数或者Promise对象，而async函数的await后面，可以是Promise和原始类型（数值、字符串和布尔值，但这时会自动转换成立即resolved的Promise对象，查看spawn函数中Promise.resolve(next.value)）


4、返回值是Promise



比Generator函数的返回值是Iterator对象方便，可以使用then方法指定下一步操作














	 
## 2、介绍下Promise，内部实现
	 
## 3、清除浮动  
	 
## 4、定位问题（绝对定位、相对定位等）
	 
## 5、从输入URL到页面加载全过程
	 
## 6、tcp3次握手
	 
## 7、tcp属于哪一层（1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)）
	 
## 8、redux的设计思想
	 
## 9、接入redux的过程
	 
## 10、绑定connect的过程
	 
## 11、connect原理
	 
## 12、webpack介绍
	 
## 13、== 和 ===的区别，什么情况下用相等==

==： 不严格相等，比较的时候回进行类型转换

===： 严格相等，比较的时候不会进行类型转换
	 
## 14、bind、call、apply的区别


	 
## 15、动画的了解
	 
## 16、介绍下原型链（解决的是继承问题吗）
	 
## 17、对跨域的了解

