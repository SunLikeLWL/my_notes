# 有赞

## 1、Linux754介绍
	
## 2、介绍冒泡排序，选择排序，冒泡排序如何优化
	
## 3、transform动画和直接使用left、top改变位置有什么优缺点
	
## 4、如何判断链表是否有环
	
## 5、介绍二叉搜索树的特点



	
## 6、介绍暂时性死区

Tempporal Dead Zone(TDZ)是ES6中对作用域新的专用语义。



### 作用域
var 全局作用域、函数作用域、eval作用域

let/const  块级作用域


### 变量提升
var 定义的变量存在提升，未定义先使用值是undefined

let/const 定义变量不存在提升，未定义先使用会报错
变量未定义之前就调用，会报错，这就是暂时性死区

### 暂时性死区


*
*
*
*
*
*
*
*
*
*
*
*



	
## 7、ES6中的map和原生的对象有什么区别
	
## 8、观察者和发布-订阅的区别
	
## 9、react异步渲染的概念,介绍TimeSlicing和Suspense
	
## 10、16.X声明周期的改变
	
## 11、16.X中props改变后在哪个生命周期中处理
	
## 12、介绍纯函数

### 概念
纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用


*
*
*
*
*
*
*
*
*
*
*
*




	
## 13、前端性能优化
	
## 14、pureComponent和FunctionComponent区别
	
## 15、介绍JSX
	
## 16、如何做RN在安卓和IOS端的适配
	
## 17、RN为什么能在原生中绘制成原生组件（bundle.js）
	
## 18、介绍虚拟DOM
	
## 19、如何设计一个localStorage，保证数据的实效性
	
## 20、如何设计Promise.all()
	
## 21、介绍高阶组件
	
## 22、sum(2,3)实现sum(2)(3)的效果

### 柯里化
#### 概念
  把接受多个参数的函数变换成接受一个单一参数的函数，并返回接受余下的参数而且返回的新函数的技术

#### 代码试下

function curry(fn,args){
    var _this = this;
    var len = fn.length;
    var args = args||[];

    return function(){
        var _args =  Array.prototype.slice.call(arguments);
        Array.prototype.push.apply(args,_args);

        // 如果参数小于最初的fn.length，则递归调用，继续收集参数
        if(_args.length<len){
             return curry.call(_this,fn,_args);
        }
        // 参数收集完毕，执行fn
        return fn.apply(this,_args);
    }
}


*
*
*
*
*
*
*
*
*
*
*
*


	
## 23、react性能优化
	
## 24、两个对象如何比较


使用遍历和递归调用，将两个对象进行比较

var deepEqual(x,y){
    // 指向同一个内存
    if(x===y){
        return true;
    }
    else if((typeof x=='object' &&x!=null) && typeof t =='object'&& y!=null){
        if(Object.keys(x).length!=Object.keys(y).length){
            return false;
        }
        for(var prop in x){
             if(y.hasOwnPrototype(prop)){
                 if(!deepEqual(x[prop],y[prop])){
                     return false;
                 }
             }
             else{
                 return false;
             }
        }
        return true;
    }
    else{
        return false;
    }
}