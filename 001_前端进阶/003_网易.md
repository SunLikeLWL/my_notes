# 网易

## 1、介绍redux，主要解决什么问题

###  React有props和state
 1、props意味着父级分发下来的属性

 2、state意味着组件内部可以自行管理状态，整个React没有数据向上回溯的能力，这就是react的单向数据流


 ### redux简介
 1、redux的诞生是为了给React应用提供可预测化的状态管理机制

 2、Redux会将整个应用状态存储到一个地方，称为store

 3、这个store里面保存一颗状态树

 4、组件改变state的唯一方法是通过调用store的disatch方法，触发一个action，这个action被对应的reducer处理，于是state完成更新

 5、组件可以通过派发（dispatch）行为（action）给store，而不是直接通知其他组件

 6、其他组件可以通过订阅store的状态来刷新自己的视图






*
*
*
*
*
*
*
*
*
*




	 
## 2、文件上传如何做断点续传
*
*
*
*
*
*
*
*
*
*
	 
## 3、表单可以跨域吗
*
*
*
*
*
*
*
*
*
*
	 
## 4、promise、async有什么区别
*
*
*
*
*
*
*
*
*
*
	 
## 5、搜索请求如何处理（防抖）
*
*
*
*
*
*
*
*
*
*
	 
## 6、搜索请求中文如何请求
*
*
*
*
*
*
*
*
*
*
	 
## 7、介绍观察者模式


### 概念
	 设计这种模式背后主要的原因是促进形成低耦合，在这种模式中不是简单的对象调用对象，而是对象‘订阅’另一个对象的活动，当对象的活动状态发生变化了改变，就去通知订阅者，而订阅者也成为观察者。
### 简单实现

  var Jack = {
     subcribers:{
       'any':[]
	 }
	 // 添加订阅
	 subscribe:function(type = 'any',fn){
		 if(!this.subscribers[type]){
			 this.subscribers[type] = [];
		 }
		 this.subscribers[type].push(fn);// 讲订阅方法保存在数组里
	 }
    
	 // 退订
     unsubscribe:function(type = 'any',fn){
		 this.subscribers[type] = this.subscribers[type].filter(function(item){
			 return item !== fn;
		 })// 将退订的方法从数组中移除
	 }
    
	// 发布订阅
	 publish:function(type = 'any',...args){
		 this.subscribers[type].forEach(function(item){
			 item(...args);
		 })
	 }
  }


 


  var Tom = {
	  readNews:function(info){
		   console.log(info);
	  }
  }

// Tom订阅Jack的报纸
Jack.subscribe("娱乐",Tom.readNews);

Jack.subscribe("体育",Tom.readNews);

// Tom退订Jack的报纸
Jack.unsubscribe("娱乐",Tom.readNews);

// Jack发布新的报纸
Jack.publish("娱乐","S.H.E演唱会惊喜登台");
Jack.publish("体育","欧国联-意大利0-1客负葡萄牙");


### 应用

可以看到观察者模式将两个对象的关系变得十分松散，当不需要订阅关系的时候删掉订阅的语句即可。



### event模块
node.js的events是一个使用率很高的模块，其他原生node.js都是基于它来完成的，比如流、HTTP等，
events模块的功能就是一个事件绑定，所有继承自它的实例都具备事件处理能力。首先它是一个类

function EventEmiter(){
    // 私有属性，保存订阅方法
    this._events = [];
}

// 默认最大监听数
EventEmitter.defaultMaxListeners = 10;

module.exports = EventEmitter;


### on方法
首先是on方法，该方法用于订阅事件，

EventEmitter.prototype  = EventEmitter.prototype.addListener = function(type,listener,flag){
    // 保证存在的实例属性
    if(!this._events){
        this._events = Object.create(null);
    }
   
     if(this._events[type]){
         if(flag){
             // 从头部输入
             this._events[type].unshift(listener);
         }
         else{
             this._events[type].push(listener);
         }
     }
     else{
         this._events[type] = [listener];
     }

     // 绑定事件，触发newListener
     if(type !== 'newListener'){
         this.emit('newListener'.type);
     }
}

<!-- 
 因为有起亚子类需要继承自EventEmitter，因此要判断子类是否存在_event属性，这样做是为了保证子类必须存在此实例属性。而flag标记是一个订阅方法的插入标识，如果为‘true’就视为插入在数组头部。

 -->


### emit方法

EventEmitter.prototype.emit = function(type,...args){
    if(this._events[type]){
        this._events[type].forEach(fn=>fn.call(this,...args));
    }
}

### once 方法

EventEmitter.prototype.once = function(type,listener){
    let _this = this;

    // 中间函数，在调用完之后立即删除订阅

    function only(){
        listener();
        _this.removeListener(type,only);
    }

    // orgin 保存原回调的引用，用于remove时的判断
    only.origin = listener;
    this.on(type,only);
}

<!-- 
 once方法非常有趣，他的功能是将事件订阅一次，当这个时间触发过就不会再次触发。其原理是将订阅的方法在包裹一层函数，在执行后将次函数移除即可
 -->


 ### off方法

 EventEmitter.prototype.off = EventEmitter.prototype.removeListener = function(type,listener){
     if(this._events[type]){
         // 过滤掉退订的方法，从数组中移除
         this._events[type] = this._events[type].filter(fn=>{
             return fn !== listener && fn.origin !== listener;
         })
     }
 }


<!-- 
off 方法即为退订，原理同观察者模式一样，将订阅者方法从数组中移除即可
 -->


 ### prependListener方法
 
 EventEmitter.prototype.prependListener = fucntion(type,listener){
     this.on(type,listener,true);
 }





*
*
*
*
*
*
*
*
*
*
	 
## 8、介绍中介者模式

### 概念

中介者模式的作用就是解除对象与对象之间的紧耦关系。增加一个中介者对象之后，所有的相关对象都通过中介者对象来通信，而不是相互引用，所以当一个对象发生变化时，只需要通知中介即可。中介者使各对象之间耦合松散，而且可以独立地改变他们之间的交互。中介者模式使得网状的多对多关系变成了相对简单的一对多






*
*
*
*
*
*
*
*
*
*




	 
## 9、观察者和订阅-发布的区别，各自用在哪里
	 
## 10、介绍react优化
	 
## 11、介绍http2.0
	 
## 12、通过什么做到并发请求
	 
## 13、http1.1时如何复用tcp连接
	 
## 14、介绍service worker
	 
## 15、介绍css3中position:sticky
	 
## 16、redux请求中间件如何处理并发
	 
## 17、介绍Promise，异常捕获
	 
## 18、介绍position属性包括CSS3新增
	 
## 19、浏览器事件流向
	 
## 20、介绍事件代理以及优缺点
	 
## 21、React组件中怎么做事件代理
	 
## 22、React组件事件代理的原理
	 
## 23、介绍this各种情况
  1、默认非严格模式全局下this指向window，严格模式下this指向undefined

  2、隐式绑定
  var obj = {
      name: 'obj',
      foo:function(){
          alert();
      }
  }
  obj.foo(); // this 指向obj

  var obj1 = {
      name:'obj1',
      obj2:{
          name:'obj2',
            foo:function(){
            alert(this.name);
        }
      }
  }

  obj1.obj2.foo();// obj2


 3、call/apply

  var obj1 = {
      name:"obj1",
      foo:function(){
          
      }
  }

  4、new


  5、箭头函数

	 
## 24、前端怎么控制管理路由
	 
## 25、使用路由时出现问题如何解决
	 
## 26、React怎么做数据的检查和变化

