# Javascript知识点


## 1、Set和Map的却别


### Set

1、set以RBTree作为底层容器；
2、所得元素的只有key没有value，value就是key
3、不允许出现键值重复
4、所有元素都会被自动排序
5、不能通过迭代器来改变set的值，以为set的值就是键

### map

map和set一样是关联式容器，他们的底层容器都是红黑树，
区别就在于map的值不作为键，键和值是分开的。
1、map以RBTree作为底层容器
2、所有元素都是键+值存在
3、不允许键重复
4、所有元素都是通过键进行排序




## 2、反向代理


实践中顾客无法直接跟服务器发起请求的时候，
我们就需要代理服务器，代理可以实现客户端与
服务器端之间的通信，我们的Nginx也可以实现相应的代理服务。
代理分为正向代理和反向代理

### 正向代理
顾客需要访问一个服务器，但是他可能无法直接访问这台服务器，这时候
可以找一台可以访问目标服务器的另一台服务器，而这台服务器就被当做代理人的角色，称之为代理服务器，于是客户端吧请求发给代理服务器，由代理服务器
获得目标服务器的数据并返回给客户端。客户端的清除目标服务器的地址的，而目标服务器是不清楚客户端，他只知道来自哪个代理服务器，所以正向代理可以屏蔽活隐藏客户端的信息



### 反向代理
方向代理就是代理服务器为服务器代理人，站在服务器这边，他就是对屏蔽了服务器信息，常用的场景就是多台服务器分布式部署，像一些大型网站，由于访问人数很多，就需要多台服务器来解决人数多的问题，这时候这些服务器就由一个反向代理服务器来代理，客户端发动请求，先由反向代理服务器，然后按一定的规则分发到明确的服务器，而顾客端不知道是那台服务器。


Nginx负载均衡


负载：就是Nginx接受请求


均衡：Nginx讲收到的请求按照一定的规则分发到不同的服务器进行处理




## 3、Hook技术

Hook技术又叫钩子函数，在系统没有调用该函数之前，钩子程序就先得到了控制权，这时候钩子函数既可以加工处理（改变）该函数的执行行为，还可以强制结束消息的传递。简单来说，就是把系统的程序拉出来变成我门自己执行代码片段。

要实现钩子函数，有两个步骤：
1、利用系统内部提供的接口，通过实现该接口，然后注入进系统（特定场景下使用）
2、动态代理（使用所有场景）



## 4、XSS攻击
XSS全称是Cross Site Scripting(为了区分CSS进行区分，就叫XSS)即跨站脚本
XSS的重点不在于跨站，而是在于脚本的执行；
XSS是一种在web应用中的计算机安全漏洞，是由于web应用的输入过滤不足而产生的
他允许恶意web用户将代码植入到提供给用户使用的页面中
### 分类
1、非持久型（反射型/DOM-based型）

2、持久型（存储型）


### 防御技术

1、对输入进行过滤：csp（网页安全策略）

2、对输出进行编码：转义字符





## 5、同源策略

### 定义与限制
如果两个url的协议、域名、端口号都相同，我们称这两个url同源。
1、同源策略限制了来自不同源的javascript脚本对当前DOM对象读和写的操作；
2、同源策略限制了不同源的站点读取当前站点的Cookie、IndexDB、LocalStorage等数据；
3、同源策略限制了通过XMLHttpRequest等方式将站点的数据发送给不同源的站点

### 解决方案
1、跨文档消息机制：可以通过window.postMessage的javascript接口和不同源的DOM进行通信
2、跨域资源共享（CORS）：跨域资源在服务器端设置允许跨域，就可以进行跨域访问控制，从而使跨域数据传输得以安全进行；
 3、内容安全策略（CSP）：主要以白名单的形式配置可信任的内容来源，在网页中，能够使白明单的内容正常执行（包块js，css，image等），而非白名单的内容无法正常执行；



 ## 6、CSRF跨站点请求伪造（Cross Site Request Forgery）
 攻击者盗用你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了一次攻击者所期望的一个操作，

### CSRF漏洞检测


### 防御CSRF攻击




## 7、图片懒加载

懒加载或者按需加载，是一种很好的优化网页或者应用的方式。
这种方式实际上是先把你的代码在一些逻辑断点处分离开，
然后在一些代码块中完成某些操作后，立即引用或者即将引用
另一些新的代码块。这样加快了应用的初始化加载速度，减轻了
他的总体体积，因为某些代码可能永远不会被加载到。


存在形式：
1、浏览网页，准备往下拖动滚动条
2、拖动一个占位图到视窗
3、占位图片被瞬间替换成最终图片






## 8、设计模式

是一套被反复使用、思想成熟、经过分类和无数实战设计检验的总结的。
使用设计模式是为了让系统代码可重用、可扩展、可解耦、更容易被人理解
且能保证代码可靠性。设计模式使代码开发真正工程化。



## 9、XMLHttpRequest实例

var xmlhttp = null;
function loadXMLDoc(url){
    if(window.XMLHttpRequest){
        xmlhtpp = new XMLHttpRequest();
    }
    else if(window.ActiveXObject){
        xmlhttp = new ActiveXObject("Mycrosoft.XMLHTTP");
    }

    if(xmlhttp){
        xmlhttp.onreadystatechange =  stage_change;
        xmlhttp .open("get",url,true);
        xmlhttp.send(null);
    }
    else{
        alert("Your brower does not suport XMLHTTP");
    }
}

function state_change(){
    if(xmlhttp.readyState==4){
        if(xmlhttp.status == 200){

        }
    }
    else{

    }
}


## 10、库和框架

库：库是更多是一个封装好的特定的集合，提供给开发者使用，
而且是特定于某一方面的集合（方法和函数），库没有控制权，
控制权在使用者手中，在库中查询需要的功能在自己的应用中使用，
我们可以从封装的角度理解库；

框架：框架顾名思义就是一套架构，会基于自身的特点向用户
提供一套相当于叫完整的解决方案，而且控制权的在框架本身，
使用者要找框架所规定的某种规范进行开发。

在实际中，像angular、backbone、vue就属于框架，
而jQuery、React、underscore就是库，在前者中我们完全可以自由的使用后者
，同时也可以没有前者的基础之上使用后者，都是很自由，
控制权始终在我们的手中，但是使用框架时候就必须按照它的规范来进行模块化的开发；


React和react-router, react-redux结合起来才叫框架，本身只是充当一个前端渲染的库而已



## 11、原型

1.在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。
即：对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。

2.方法(Function)
方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。




## 12、异步加载脚本

function loadScript(url){
    <!-- 获取head节点 -->
    var head = documnet.head|| documnet.getElementByTagName("head")[0];

    <!-- 创建script标签 -->
    var script = document.createElemet("script");
   
   <!-- 给script标签赋值 -->
    script.src = url;

  <!-- 监听script脚本内容加载完成 -->
    script.onload = script.onreadystatechange = function(){
        if(!this.readyState || this.readyState == 'loaded' || this.readyState=='complete'){
            //func();
            script.onload() = script.onreadystatechange = null;
        }
    }

    <!-- 将脚本插入到head标签内 -->
    head.insertBefore(script,0)
}





## 13、javascript调用堆栈

### 执行上下文
  当前javascript代码被解析和执行是所在环境的抽象概念，
  javascript中运行任何的代码都是在执行上下文中运行。


  ### 分类

  #### 全局执行上下文
       这是默认的，最基础的执行上下文。
       1、创建全局对象，在浏览器中这个全局对象就是window对象；
       2、将this指针指向这个全局对象
       一个程序只存在一个执行上下文


 #### 函数执行上下文
      每次函数调用时，都会为改函数创建一个新的执行上下文。每个函数
      否拥有执行上下文，但是只有在函数被调用的时候才会被创建。一个程序
      中可以存在多个函数执行上下文，这些函数执行上下文按照特定的顺序
      执行一系列的步骤；



#### Eval函数执行上下文
     运行eval函数中的代码也获得了自己的执行上下文，Eval方法是在运行时对脚本进行解释执行，
     而普通的javascript会有一个预处理的过程。所以会有一些性能上的损失；eval也存在一个安全问题，
     因为他可以执行传给他的任何字符串，所以永远不要传入字符串或者不明来历和不收信任来源的参数




### 执行栈
执行栈，也叫调用栈，具有LIFO（Last In First Out后进先出）结构，用于存储在代码执行期间创建的
所有执行上下文。


当Javascript引擎首次读取脚本时，会创建一个全局执行上下文并将其Push到当前执行栈中。
每当发生函数调用时，引擎都会为改函数创建一个新的执行上下文并Push到当前执行栈的栈顶。

引擎会运行执行栈中的Pop出，上下文控制权讲转到当前执行栈的下一个执行上下文。





### 词法环境Lexical Environment

词法环境是一种规范类型，基于ECMAScript代码的词法嵌套结构来定义标识符与特定变量和函数的关联关系
词法环境由环境记录（environment record）和可能为空引用（null）的外部词法环境组成


#### 组成

   1、环境记录（environment record）
   存储变量和函数声明的实际位置；
   2、对外环境的引用
   意味着他可以访问其外部词法环境



#### 词法环境
    
     全局环境（在全局执行上下文中）是一个没有外部环境词法的词法环境。全局环境的外部环境应用为null。
     他拥有一个全局对象，以及相关的方法和属性以及任何用户自定义的全局变量，this的值指向这个全局对象


#### 函数环境 
     用户在函数中定义的变量被存储在环境记录中，包含了arguments对象。对外部环境的引用可以是全局环境，
     也可以是包含在内部函数的外部函数环境






## 14、脚本
   脚本（script）是一种批处理文件的延伸，是一种纯文本保存的程序，一般来说的计算机脚本程序是确定的一系列控制计算机进行运算操作的组合，在其中可以实现一定的逻辑分支等
 

## 15、语法糖

  也翻译为糖衣语法，指计算机中添加的某种语法，这种语法对语言的功能并没有影响，但是方便程序员使用。通常来说用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。





##  16、修饰器


装饰器不仅可以修饰类，还可以修饰类的属性


