# 前端高级进阶

##  1、调用堆栈  *******************************************************

执行上下文就是当前javascript代码被解析和执行是所在环境的抽象概念，javascript中运行任何代码都是在执行上下文中运行的。
a、全局上下文
b、函数执行上下文
c、Eval函数执行上下文

执行栈，也叫调用栈，具有LIFO(Last In First Out)结构，用于存储在代码执行期间创建的所有执行上下文；

当javascript引擎首次读取脚本时，会创建一个全局执行上下文并将其Push到当前执行栈中。每当发生函数调用
时，引擎就会为该函数创建一个新的执行上下文并push到当前执行栈的栈顶；

引擎会运行执行上下文在执行栈栈顶的函数，根据LIFO规则，当前函数运行完成后，其对应的执行上下文将会从执行栈中
pop出，上下文控制权转到当前执行栈的下一个执行上下文；






## 2、作用域闭包  

### 概念
 函数与对其状态即词法环境的应用共同构成闭包(closure)。也就是说，闭包可以让你从内部函数访问外部函数作用域
。在javascript，函数在每次创建是生成闭包





## 3、this 全面解析 *******************************************************

### 前言
this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

### 总结
函数被调用时发生this绑定，this指向什么完全取决于函数在哪里被调用。

### this的绑定规则

1、默认绑定
 
 独立函数调用：独立函数调用时的this使用默认绑定规则，默认绑定规则下的this指向window(全局对象)
 严格模式：this无法使用默认绑定，this会绑定undefined


2、隐式绑定

当函数引用有上下文对象的时，隐式绑定规则会把函数中的this绑定到这个上下文对象

 var obj = {
     name:"xixi",
     foo:function(){
         console.log(this.name)
     }
 }

obj.foo();

对象属性引用链中只有上一层或者说最后一层在再调用中起作用

obj.obj1.foo();

 var obj = {
     name:"xixi",
     obj1:{
         name:"wenwen",
         foo:function(){
            console.log(this.name)
        }
     }
 }

隐式丢失： 被隐式绑定的函数会丢失绑定对象，而应用默认绑定，把this绑定到全局对象或者undefined(严格模式)上。


 
var a = "global";
var obj = {
    a:"obj",
    foo:function(){
        console.log(this.a);//global
    }
}
var bar = obj.foo;//函数别名
bar(); 


 
 var a = "global";
 var obj = {
     a: "obj",
     foo:function(){
         console.log(this.a);//global
     }
 }
var bar = obj.foo;//函数别名
function doFoo(fn){
    fn();
}
doFoo(bar); //global

setTimeout(obj.foo,3000)

3、显示绑定

通过call()和apply()方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this上，称之为显示绑定

4、new绑定
使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
 创建（或者说构造）一个新的对象
 这个新的对象被执行[[原型]]链接
 这个新对象会绑定到函数调用的this
 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象

优先级：
new > call/apply > 隐式 > 默认




## 4、深浅拷贝原理 *******************************************************
### 浅拷贝
只拷贝对象的基本类型值，并不复杂引用类型的值而是引用他的指针，
var a = {
    name: 12
}
var b = a;
b只是引用a的指针


### 深拷贝
深拷贝可以拥有一个对象所有属性和方法，实现真正的"独立自主"，不引用原来对
象的指针，开辟新的内存空间，和原来的对象不会相互影响


### 浅拷贝实现方法

  1、Object.assign();

   拷贝的只是属性值,只实现第一层的深拷贝，而不能进行深层的深拷贝，所以这个方法属于浅拷贝

  2、Object.create();
   这个方法创建了一个新的对象，使用现有的对象来提供新创建的对象的__proto__，实际上是地址引用，


   3、扩展运算符等
   let a = [1,2,3];
   let b = [...a];
   
   只是基于基本类型值的引用，并没有开辟新的空间

   


  ### 深拷贝实现方法

 1、JSON.parse(JSON.stringify(obj));

 

 2、利用递归的方法和for in遍历属性进行深拷贝

 function deepCopy(initialObj,copyObj){
     var obj =  copy||{};
     for(let i in initialObj){
         var prop = initialObj[i];
         if(typeof prop ==="obj"){
             obj[i] = prop.constructor===Array?[]:{},
             deepCopy(prop,obj[i]);
         }
         else{
             obj[i] = prop;
         }
     }
     return obj;
 }




## 5、原型 Prototype  

### 基本概念
每个函数都有一个prototype属性。
此属性是一个指针，能够指向一个对象，而且对象将会被构造函数创建的对象实例所共享，也就是会继承此对象
### 总结:
prototype所指向的对象是被构造函数所创建的对象实例所共用共享的。
创建的对象实例有一个内部属性[[Prototype]]，他是一个指针，指向函数原型(prototype)指向的对象。




## 6、高阶函数  *******************************************************
   
   ### 高级函数
   参数或者是函数返回值是函数的函数。

   ### AOP面向切片编程
   1、当需要使用某个公共函数时需要这个函数执行前添加自己的逻辑，
   2、通常我们的做法不能是直接修改这个函数；
   3、而是通过AOP的方法利用高级函数和原型链的特点处理


   function say(name){
       console.log(name)
   }

   function before(){
       console.log("say前执行");
   }

   Function.prototype.beforeFn = function(){
       return (...argd)=>{
           before();
           this(...args);
       }
   }

   let beforeSay = say.beforeFn(before);

   beforeSay("xixi")



## 7、事件机制 *******************************************************
   
   ### 事件
   文档或者浏览器窗口中发生的一些特定的交互瞬间，js和html的交互就是通过事件来实现的。
   可以使用监听器（或者处理程序）来预定事件，以便事件发生时执行相应的代码。

   ###  事件流
   描述的是从页面中就收事件的顺序。但是IE跟Netscape提出了差不多的完全相反的概念。IE
   的事件流式事件冒泡流，Netscape的事件流是事件捕获流。

   ### 事件冒泡
   IE的事件流叫事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点。

   ### 事件捕获
   Netscape提出了另一个事件流叫事件捕获。事件捕获的用意在于在事件达到预定目标之前捕获他




## 8、Event Loop 原理  
 
 ### 概念
 Event Loop 即事件循环，是指浏览器或Node的一种解决javascript单线程运行时不会阻塞的一种
 机制，也就时我们经常使用异步的理由。

### 堆
堆是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种是大堆，一种是小堆，
将根节点最大的堆叫最大堆或者大跟堆，根节点是最小的堆叫做最小堆或者小根堆。堆是线性数据结构，
相当于一维数组，有唯一后继。

### 栈
栈在计算机中是限定仅在表尾进行插入或者删除操作的线性表。栈是一种数据结构，他按照后进先出的
原则储存数据，先进的数据被压入栈底，最后的数据在栈顶，需要读取数据的时候从栈顶开始弹出数据。
栈是只能在某一端插入和删除的特殊线性表。

### 队列
只允许在表的前端(front)进行删除操作，而在后端的(rear)进行插入操作，和栈一样，队列是一种
受限的线性表


*
*
*
*
*
*
*
*
*
*


  



## 9、Promise 原理

### 1、基本结构
new Promise((resolve,reject)=>{
       setTimeout(()=>{
           resolve("FULFiLLED)
       })
})


构造函数promise必须接受一个函数作为参数，我们称该函数为handle，handle有包含resolve和reject两个参数，他们是两个函数。


定义一个判断一个变量是否为函数的方法，后面会用到

const isFunction = variable => typeof variable==== 'function';


首先，我么定义一个名为MyPromise的Class，他接受一个函数handle作为参数


class MyPromise{
    construtor(handle){
        if(!isFunction(handle){
            throw new Error("MyPromise must accept a function as parameter");
        })
    }
}


### 2、转台和值

Promise对象存在以下三种状态：


1、Pending 进行中

2、Fulfilled 已成功

3、Rejected 已失败

状态只会由Pending变成Fulfilled或者由Pending变成Rejected，而且状态改变之后不会再发生变化，会一直保持这个状态。


Promise的值是指状态改变时传递给回调函数的值


上文中handle函数包含resolve和reject两个参数，可以用于改变Promise的状态和传入Promise的值

new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve('FULFilled');
    },1000)
})



这里resolve传入的"FulFilled"就是Promise的值



resolve和reject


1、resolve：将Promise对象的状态从Pending变为Fulfilled

2、reject：将Promise对象的状态从Pending变为Reject

3、resolve和reject都可以传入任意类型的值作为参数，表示Promise对象成功Fulfilled和失败Rejected



### 3、Promise的then方法


 promise.then(onFulfilled,onRejected);

 

 ### 完整源码

// 判断变量否为function
const isFunction = variable => typeof variable === 'function'
// 定义Promise的三种状态常量
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
    constructor(handle) {
        if (!isFunction(handle)) {
            throw new Error('MyPromise must accept a function as a parameter')
        }
        // 添加状态
        this._status = PENDING
        // 添加状态
        this._value = undefined
        // 添加成功回调函数队列
        this._fulfilledQueues = []
        // 添加失败回调函数队列
        this._rejectedQueues = []
        // 执行handle
        try {
            handle(this._resolve.bind(this), this._reject.bind(this))
        } catch (err) {
            this._reject(err)
        }
    }
    // 添加resovle时执行的函数
    _resolve(val) {
        const run = () => {
            if (this._status !== PENDING) return
            this._status = FULFILLED
            // 依次执行成功队列中的函数，并清空队列
            const runFulfilled = (value) => {
                let cb;
                while (cb = this._fulfilledQueues.shift()) {
                    cb(value)
                }
            }
            // 依次执行失败队列中的函数，并清空队列
            const runRejected = (error) => {
                let cb;
                while (cb = this._rejectedQueues.shift()) {
                    cb(error)
                }
            }
            /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
              当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
            */
            if (val instanceof MyPromise) {
                val.then(value => {
                    this._value = value
                    runFulfilled(value)
                }, err => {
                    this._value = err
                    runRejected(err)
                })
            } else {
                this._value = val
                runFulfilled(val)
            }
        }
        // 为了支持同步的Promise，这里采用异步调用
        setTimeout(run, 0)
    }
    // 添加reject时执行的函数
    _reject(err) {
        if (this._status !== PENDING) return
        // 依次执行失败队列中的函数，并清空队列
        const run = () => {
            this._status = REJECTED
            this._value = err
            let cb;
            while (cb = this._rejectedQueues.shift()) {
                cb(err)
            }
        }
        // 为了支持同步的Promise，这里采用异步调用
        setTimeout(run, 0)
    }
    // 添加then方法
    then(onFulfilled, onRejected) {
        const { _value, _status } = this
        // 返回一个新的Promise对象
        return new MyPromise((onFulfilledNext, onRejectedNext) => {
            // 封装一个成功时执行的函数
            let fulfilled = value => {
                try {
                    if (!isFunction(onFulfilled)) {
                        onFulfilledNext(value)
                    } else {
                        let res = onFulfilled(value);
                        if (res instanceof MyPromise) {
                            // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                            res.then(onFulfilledNext, onRejectedNext)
                        } else {
                            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                            onFulfilledNext(res)
                        }
                    }
                } catch (err) {
                    // 如果函数执行出错，新的Promise对象的状态为失败
                    onRejectedNext(err)
                }
            }
            // 封装一个失败时执行的函数
            let rejected = error => {
                try {
                    if (!isFunction(onRejected)) {
                        onRejectedNext(error)
                    } else {
                        let res = onRejected(error);
                        if (res instanceof MyPromise) {
                            // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                            res.then(onFulfilledNext, onRejectedNext)
                        } else {
                            //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                            onFulfilledNext(res)
                        }
                    }
                } catch (err) {
                    // 如果函数执行出错，新的Promise对象的状态为失败
                    onRejectedNext(err)
                }
            }
            switch (_status) {
                // 当状态为pending时，将then方法回调函数加入执行队列等待执行
                case PENDING:
                    this._fulfilledQueues.push(fulfilled)
                    this._rejectedQueues.push(rejected)
                    break
                // 当状态已经改变时，立即执行对应的回调函数
                case FULFILLED:
                    fulfilled(_value)
                    break
                case REJECTED:
                    rejected(_value)
                    break
            }
        })
    }
    // 添加catch方法
    catch(onRejected) {
        return this.then(undefined, onRejected)
    }
    // 添加静态resolve方法
    static resolve(value) {
        // 如果参数是MyPromise实例，直接返回这个实例
        if (value instanceof MyPromise) return value
        return new MyPromise(resolve => resolve(value))
    }
    // 添加静态reject方法
    static reject(value) {
        return new MyPromise((resolve, reject) => reject(value))
    }
    // 添加静态all方法
    static all(list) {
        return new MyPromise((resolve, reject) => {
            /**
             * 返回值的集合
             */
            let values = []
            let count = 0
            for (let [i, p] of list.entries()) {
                // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
                this.resolve(p).then(res => {
                    values[i] = res
                    count++
                    // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
                    if (count === list.length) resolve(values)
                }, err => {
                    // 有一个被rejected时返回的MyPromise状态就变成rejected
                    reject(err)
                })
            }
        })
    }
    // 添加静态race方法
    static race(list) {
        return new MyPromise((resolve, reject) => {
            for (let p of list) {
                // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
                this.resolve(p).then(res => {
                    resolve(res)
                }, err => {
                    reject(err)
                })
            }
        })
    }
    finally(cb) {
        return this.then(
            value => MyPromise.resolve(cb()).then(() => value),
            reason => MyPromise.resolve(cb()).then(() => { throw reason })
        );
    }
}






*
*
*
*
*
*
*
*
*
*



10、Async/Await 原理



*
*
*
*
*
*
*
*
*
*
## 11、防抖/节流原理  *******************************************************

###  缘由

在使用resize、scroll、mousemove等等事件时，会持续触发事件


### 防抖  

   防抖就是指触发事件后在n秒内函数只能执行一次，如果n秒内又触发了事件，则会重新计算函数执行时间。
   

   防抖函执行分为非立即执行和立即执行。


   非立即执行：
   function debouce(func,wait){
       let timeout;
       return function(){
           let context = this;
           let args = arguments;
           if(timeout){
               clearTimeout(timeout);
           }
           timeout = setTimeout(function(){
             func.apply(context,args);
           },wait)
       }
   }


   立即执行：

   function debouce(func,wait){
       let timeout;
       return function(){
           let context = this;
           let args = arguments;
           if(timeout){
               clearTimeout(timeout);
           }
           var callNow = !timeout;
           timeout = setTimeout(function(){
             func.apply(context,args);
           },wait)

           if(callNow){
               func.apply(context,args);
           }
       }
   }


   ### 节流

   节流就是指触发事件但是在n面内只执行一次函数。节流会稀释函数的执行频率。


  时间戳：
  function throttle(func,wait){
      var previous = 0;
      return function(){
          let now = Date.now();
          let context = this;
          var args = arguments;
          if(now-previous>wait){
              func.apply(context,args);
              previous = now;
          }
      }
  }


  function throttle(func,wait){
      let timeout;
      return function(){
          let context = this;
          let args = arguments;
          if(!timeout){
            setTimeout(function(){
                 timeout = null;
                 func.apply(context,args);      
            },wait)
          }
      }
  }



 
## 12、模块化详解 *******************************************************


### AMD

ADM，Asynchtonous Module Definition，异步模块定义。他是一个浏览器端模块化开发规范。
他不是原生支持的，所以使用AMD规范进行页面开发需要对应的库，也就是requireJS，AMD
在推广的过程中对模块定义的范围话的产生

#### require
  用来引入模块的函数
  1、解决js文件存在依赖关系时，被依赖的文件需要早于依赖他的文件加载到浏览器；
  2、js加载的时候浏览器会阻塞渲染线程，加载文件越多，页面失去响应的时间越长。

#### define
用来定义模块的函数


### CMD
 CMD，common Module Definition，通用模块定义。CMD是在sea.js推广过程中产生的。在CMD规范中，一个模块就是一个文件。



 ### Commonjs 

 Nodejs是Commonjs规范的只要时间者。他有四个重要环境变量为模块化的实现提供支持：
 module、export、require、global。

 module.exports(不推荐使用exports)定义对外输出的API
 require引用模块

 
 #### 模块引用

 const fs  = require("fs");
 
 步骤：
 1、如果是核心模块，如fs，则直接返回模块；
 
 2、如果是路径，则拼接成一个绝对路径，然后继续读取缓存require.cache再读取文件

 3、首次加载后的模块会在require.cache中，所以多次require，得到的对象是同一个对象（引用对象）

 4、在执行模块代码的时候，会将模块包装成一下模式，以便于作用域在模块范围之内

 (function(exports,require,__filename,__dirname){
    // Module
 });

 5、包装之后的代码通过vm原生代码块的runThisContext()方法执行类，返回一个function对象。最后得到当前模块对象
 的exports、require方法、module以及文件定位中得到的完整文件路径和文件目录传递微这个函数执行。


#### 模块定义

function fn(){

}
exports.propName =  fn;

module.exports = fn;


一个module对象代表模块本身，exports是module的属性。一般通过exports上挂载属性即可定义导出，也可以直接给module.exports
赋值来定义导出


#### 模块标识
    模块标识就是传递给require()方法的参数，可以是相对路径或者绝对路径，也可以是符合小驼峰命名的字符串。



### ES6模块








*
*
*
*
*
*
*
*
*
*
13、ES6 重难点
*
*
*
*
*
*
*
*
*
*
14、计算机网络概述
*
*
*
*
*
*
*
*
*
*


## 15、浏览器渲染原理

 1、浏览器会解析Html/SVG/XHTML,CSS,javascript
   分别生成DOM Tree，CSS规则树，通过DOM API 和CSSOM API来操作 DOM Tree 和CSS Rule Tree

 2、解析完成之后就是通过DOM API 和CSSOM API 来操作DOM Tree 和CSS Rule Tree.

 3、最终通过调用操作系统Native GUI的API绘制


 





*
*
*
*
*
*
*
*
*
*
16、webpack 配置
*
*
*
*
*
*
*
*
*
*
17、webpack 原理
*
*
*
*
*
*
*
*
*
*
18、前端监控
*
*
*
*
*
*
*
*
*
*
19、跨域和安全
*
*
*
*
*
*
*
*
*
*
20、性能优化
*
*
*
*
*
*
*
*
*
*
21、VirtualDom 原理
*
*
*
*
*
*
*
*
*
*
22、Diff 算法
*
*
*
*
*
*
*
*
*
*
23、MVVM 双向绑定
*
*
*
*
*
*
*
*
*
*
24、Vuex 原理
*
*
*
*
*
*
*
*
*
*
25、Redux 原理
*
*
*
*
*
*
*
*
*
*
26、路由原理
*
*
*
*
*
*
*
*
*
*
27、VueRouter 源码解析
*
*
*
*
*
*
*
*
*
*
28、ReactRouter 源码解析
*
*
*
*
*
*
*
*
*
*