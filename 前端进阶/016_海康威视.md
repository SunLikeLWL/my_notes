# 海康威视


 ## 1、knex连接数据库响应回调



*
*
*
*
*

	 
 ## 2、介绍异步方案
 
### 1、回调函数
优点：
简单、容易理解和实现
缺点：
不利于代码的阅读和维护，各个部分之间高度耦合，使得程序混乱难以追踪，而且每个任务只能指定一个回调函数。此外它不能用try catch捕获错误，不能直接return。

### 2、事件监听
异步代码的执行不取决于代码的顺序，而是取决于某个事件是否发生。



### 3、发布订阅
  我们假定，存在一个‘信号中心’，某个任务执行完成，就向信号中心‘发布’一个信号，其他的任务可以向订阅中心‘订阅’这个信号，从而知道什么时候自己可以开始执行。这就叫做‘发布/订阅模式’，又称‘观察者模式’

jQuery.subscribe('done',f2);


function f1(){
    setTimeout(function(){
        jQuery.publish('done');
    },1000)
}

### 4、promise/A+

Pending: Promise对象实例创建时候得初始状态

Fulfilled: 完成状态

Rejected： 拒绝状态


var p = new Promise((resolve,reject)=>{
    reject("reject");
    resolve("resolve");
})

p.then(value=>{
    console.log(value)
},
reason=>{
    console.log(reason);
}
)


### 5、生成器Generators/yield

语法上可以理解Generators是ES6提供的一种异步编程的解决方案，语法于传统函数完全不同，Generator最大特点就是可以控制函数的执行。

1、语法上，首先可以把它理解成，Generator函数时一个状态机，封装了多个内部状态；
2、Generator函数除了状态机，还是一个遍历器对象生成函数；
3、 可暂停函数，yield可暂停，next方法可以启动，每次启动的是yield后的表达式结果；
4、yeild表达式本身没有返回值，或者说是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。

function *foo(x){
    let y = 2* (yield(x+1));
    let z = yield(y/3);
    return (x+y+z);
}


let it = foo(5);


console.log(it.next());// {value:6,done:false};
console.log(it.next(12));//{value:8,done:false};
console.log(it.next(13));//{value:42,done: true}



### 6/async/await

1、async/await是基于promise实现的，他不能用于普通的回调函数；
2、async/await与promise一样是非阻塞的；
3、async/await使得异步代码看起来像同步代码；



    
	 
 ## 3、如何处理异常捕获

 ## 4、	 项目如何管理模块
	 
 ## 5、前端性能优化
	 
 ## 6、JS继承方案
	 
 ## 7、如何判断一个变量是不是数组
	 
 ## 8、变量a和b，如何交换
	 
 ## 9、事件委托
	 
 ## 10、多个<li>标签生成的Dom结构是一个类数组
	 
 ## 11、类数组和数组的区别
	 
 ## 12、dom的类数组如何转成数组
	 
 ## 13、介绍单页面应用和多页面应用
	 
 ## 14、redux状态树的管理
	 
 ## 15、介绍localstorage的API

